package amf.shapes.internal.domain.resolution.shape_normalization

import amf.core.client.scala.model.domain._
import amf.core.internal.annotations._
import amf.core.internal.metamodel.Field
import amf.core.internal.metamodel.domain.ShapeModel
import amf.core.internal.validation.CoreValidations.RecursiveShapeSpecification
import amf.shapes.client.scala.model.domain._
import amf.shapes.internal.domain.metamodel._
import scala.collection.mutable

case class ShapeInheritanceResolver()(implicit val context: NormalizationContext) {

  private val visitedIds = mutable.ArrayBuffer[String]()

  // This variable is used to back track
  private var detectedRecursion = false

  // ID of the shape where inheritance recursion was detected
  private var recursionGenerator = "fakeId"

  /** When resolving inheritance we first normalizeWithoutCaching. Therefore:
    *   - registerVisit is used to skip checking recursion (since we are normalizing the same shape that we started we
    *     will always detect recursions)
    *   - withoutCaching is used to skip adding the resulting normalized shape to the cache
    */
  private var registerVisit  = true
  private var withoutCaching = false

  private def runWithoutCaching[T](fn: () => T): T = {
    withoutCaching = true
    registerVisit = false
    val t: T = fn()
    withoutCaching = false
    registerVisit = true
    t
  }
  private def normalizeWithoutCaching(s: Shape): Shape = runWithoutCaching(() => normalize(s))
  private def addToCache(shape: Shape)                 = if (!withoutCaching) context.resolvedInheritanceCache + shape

  def normalize(shape: Shape): Shape = {
    context.resolvedInheritanceCache.get(shape.id) match {
      case Some(resolvedInheritance) => resolvedInheritance
      case _                         => normalizeAction(shape)
    }
  }

  protected def normalizeAction(shape: Shape): Shape = {
    shape match {
      case s if inheritanceRecursionDetected(s) && registerVisit =>
        invalidRecursionError(shape)
        detectedRecursion = true
        recursionGenerator = shape.id
        shape
      case s if hasSuperTypes(s) =>
        visitedIds.append(shape.id)
        val resolvedShape = resolveInheritance(s)
        visitedIds.remove(visitedIds.size - 1)
        addToCache(resolvedShape)
        // context.resolvedInheritanceCache + (resolvedShape, shape.id) // Necessary?
        resolvedShape
      case any: AnyShape => AnyShapeAdjuster(any) // Analyze if it's possible to remove this case. Affects MinShape?
      case _             => shape
    }
  }

  private def resolveInheritance(shape: Shape): Shape = {
    if (isEndpointSimpleInheritance(shape)) {
      resolveSimpleInheritance(shape)
    } else {
      val superTypes = shape.inherits
      shape.fields.removeField(ShapeModel.Inherits)
      val resolvedShape = inheritFromSuperTypes(shape, superTypes)

      // Reset when we return to the first Shape of the cycle
      if (detectedRecursion && shape.id == recursionGenerator) detectedRecursion = false

      registerVisit = false
      normalize(resolvedShape)
      registerVisit = true

      // This is necessary due to a limitation we have with examples in Restriction Computation (what is this limitation)
      // Shouldn't be here
      shape match {
        case any: AnyShape if isSimpleInheritance(any, superTypes) =>
          ExamplesCopier(normalize(superTypes.head), resolvedShape)
        case _ => // Nothing to do
      }

      resolvedShape
    }
  }

  private def inheritFromSuperTypes(shape: Shape, superTypes: Seq[Shape]) = {
    // [SN] TODO why does this start with a NormalizeWithoutCaching? To call the AnyShapeAdjuster?
    superTypes.fold(normalizeWithoutCaching(shape))({ (accShape, superType) =>
      val normalizedSuperType = normalize(superType)
      if (detectedRecursion) accShape else context.minShape(accShape, normalizedSuperType)
    })

  }

  private def resolveSimpleInheritance(shape: Shape) = {
    // Check if we should clone here
    val referencedShape = shape.inherits.head
    shape.fields.removeField(ShapeModel.Inherits)
    val resolvedShape = normalize(referencedShape)
    if (shape.annotations.contains(classOf[AutoGeneratedName])) referencedShape.add(AutoGeneratedName())
    ExamplesCopier(shape, resolvedShape)
    context.resolvedInheritanceCache + (resolvedShape, shape.id)
    resolvedShape
  }

  private def hasSuperTypes(shape: Shape) = shape.inherits.nonEmpty

  private def isSimpleInheritance(shape: Shape, superTypes: Seq[Shape] = Seq()): Boolean = {
    shape match {
      case ns: NodeShape =>
        superTypes.size == 1 && ns.annotations.contains(classOf[DeclaredElement]) && ns.properties.isEmpty
      case _: AnyShape if superTypes.size == 1 =>
        val superType = superTypes.head
        val ignoredFields =
          Seq(
            ShapeModel.Inherits,
            ShapeModel.Name,
            ShapeModel.DisplayName,
            ShapeModel.Description,
            AnyShapeModel.Examples,
            AnyShapeModel.Documentation,
            AnyShapeModel.Comment
          )
        fieldsPresentInSuperType(shape, superType, ignoredFields)
      case _ => false
    }
  }

  private def isEndpointSimpleInheritance(shape: Shape): Boolean = shape match {
    case anyShape: AnyShape if anyShape.annotations.contains(classOf[DeclaredElement]) => false
    case anyShape: AnyShape =>
      anyShape match {
        case any: AnyShape if any.inherits.size == 1 =>
          val superType     = any.inherits.head
          val ignoredFields = Seq(ShapeModel.Inherits, AnyShapeModel.Examples, AnyShapeModel.Name)
          fieldsPresentInSuperType(shape, superType, ignoredFields)
        case _ => false
      }
  }

  private def fieldsPresentInSuperType(shape: Shape, superType: Shape, ignoredFields: Seq[Field] = Seq()): Boolean = {
    val effectiveFields = shape.fields.fields().filterNot(f => ignoredFields.contains(f.field))
    // To be a simple inheritance, all the effective fields of the shape must be the same in the superType
    effectiveFields.foreach(e => {
      superType.fields.entry(e.field) match {
        case Some(s) if s.value.value.equals(e.value.value)                              => // Valid
        case _ if e.field == NodeShapeModel.Closed && !superType.isInstanceOf[NodeShape] => // Valid
        case _                                                                           => return false
      }
    })
    true
  }

  private def inheritanceRecursionDetected(shape: Shape) = visitedIds.contains(shape.id)

  private def invalidRecursionError(lastVersion: Shape): Unit = {
    context.errorHandler.violation(
      RecursiveShapeSpecification,
      lastVersion.id,
      None,
      "Cyclic inheritance",
      lastVersion.position(),
      lastVersion.location()
    )
  }
}
