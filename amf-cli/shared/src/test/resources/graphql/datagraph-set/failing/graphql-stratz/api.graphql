schema {
  query: DotaQuery
  mutation: DotaMutation
  subscription: DotaSubscription
}

type AbilityActiveListType {
  time: Int!
  ability0: Short
  ability1: Short
  ability2: Short
  ability3: Short
  ability4: Short
  ability5: Short
  ability6: Short
  ability7: Short
}

type AbilityAttributeType {
  name: String
  value: String
  linkedSpecialBonusAbilityId: Short
  requiresScepter: Boolean!
}

type AbilityCustomGameLanguageType {
  displayName: String
  description: String
}

type AbilityCustomGameType {
  id: Short
  name: String
  abilityName: String
  language: AbilityCustomGameLanguageType
}

enum AbilityDispellEnum {
  NONE
  NO
  YES
  YES_STRONG
}

type AbilityLanguageType {
  displayName: String
  description: [String]
  attributes: [String]
  lore: String
  aghanimDescription: String
  shardDescription: String
  notes: [String]
}

type AbilityLearnEventsType {
  time: Int!
  abilityId: Short
  levelObtained: Int!
  level: Int!
  isUltimate: Boolean
  isTalent: Boolean
  isMaxLevel: Boolean
}

type AbilityStatType {
  abilityId: Short
  type: Int
  behavior: Long
  unitTargetType: Long
  unitTargetTeam: Int
  unitTargetFlags: Long
  unitDamageType: Int
  spellImmunity: Int
  modifierSupportValue: Float
  modifierSupportBonus: Short
  isOnCastbar: Boolean
  isOnLearnbar: Boolean
  fightRecapLevel: Short
  isGrantedByScepter: Boolean
  hasScepterUpgrade: Boolean
  maxLevel: Byte
  levelsBetweenUpgrades: Byte
  requiredLevel: Byte
  hotKeyOverride: String
  displayAdditionalHeroes: Boolean
  castRange: [Int]
  castRangeBuffer: [Int]
  castPoint: [Float]
  channelTime: [Float]
  cooldown: [Float]
  damage: [Float]
  manaCost: [Float]
  isUltimate: Boolean
  duration: String
  charges: String
  chargeRestoreTime: String
  isGrantedByShard: Boolean
  dispellable: AbilityDispellEnum
}

type AbilityType {
  id: Short
  name: String
  uri: String
  language: AbilityLanguageType
  stat: AbilityStatType
  attributes: [AbilityAttributeType]
  drawMatchPage: Boolean
  isTalent: Boolean
}

type AbilityUsedEventsType {
  time: Int!
  abilityId: Short
  attacker: Short
  target: Short
}

type AdminMutation {
  mergeProSteamAccount(request: [MergeProSteamAccountRequestType]!): Boolean
  deleteProSteamAccount(request: DeleteProSteamAccountRequestType!): Boolean
}

type AdminQuery {
  """Returns a list of Stratz blogs."""
  apiMemoryReport: [String]
}

type AssistDetailType {
  time: Int!
  attacker: Short
  target: Short
  gold: Int
  xp: Int
  subTime: Int
  positionX: Int
  positionY: Int
}

enum BasicRegionType {
  CHINA
  SEA
  NORTH_AMERICA
  SOUTH_AMERICA
  EUROPE
}

type BlogMetaTagInfoType {
  id: Short
  name: String!
}

type BlogMetaTagType {
  id: Byte
  blogId: Byte
  blogMetaTagTypeId: Short
  metaTag: BlogMetaTagInfoType
}

type BlogType {
  id: Byte
  captainJackIdentityId: Guid
  title: String!
  bannerImageUrl: String!
  poster: SteamAccountType
  data: String!
  liveDateTime: DateTime
  metaTags: [BlogMetaTagType]
  link: String!
}

enum BuildingType {
  FORT
  TOWER
  BARRACKS
  HEALER
  OUTPOST
}

type BuyBackDetailType {
  time: Int!
  heroId: Short
  deathTimeRemaining: Int!
  cost: Int!
}

scalar Byte

type CaptainJackIdentityApiApplicationType {
  captainJackIdentityId: Guid
  tokenType: StratzApiType
  emailAddress: String
  discordAddress: String
  websiteAddress: String
  description: String
  isApproved: Boolean
  apiKey: String
  secretKey: String
  issuer: String
  matomoReferenceToken: String
}

type CaptainJackIdentityPrivateProfileType {
  captainJackIdentityId: Guid
  name: String
  email: String
  twitter: String
  facebook: String
  twitch: String
  youTube: String
  premiumEndDate: Long
  isAdmin: Boolean
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean!
  weeklyEmail: Boolean!
  monthlyEmail: Boolean!
  proCircuitFeedLevel: Byte
  proCircuitEmailLevel: Byte
  themeType: Byte
  languageId: Byte
  emailValidationCode: String
  isEmailValidated: Boolean!
  emailHour: Byte
  lastReadFeedTime: Long
  lastDailyEmail: Long
  lastWeeklyEmail: Long
  lastMonthlyEmail: Long
  lastLeagueDailyEmail: Long
  lastTeamDailyEmail: Long
  lastProCircuitDailyEmail: Long
  unsubscribeCode: String
  lastSeen: Long
}

input CaptainJackIdentityProfileUpdateRequestType {
  email: String
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  proCircuitFeedLevel: Byte
  proCircuitEmailLevel: Byte
  themeType: Byte
  languageId: Byte
  emailHour: Byte
  isStratzAnonymous: Byte
}

type CaptainJackIdentityPublicProfileType {
  captainJackIdentityId: Guid
  name: String
  twitter: String
  facebook: String
  twitch: String
  youTube: String
  isAdmin: Boolean
}

type CaptainJackIdentityType {
  id: Guid
  steamAccountId: String
  steamAccount: SteamAccountType
  profile: CaptainJackIdentityPublicProfileType
}

type ClusterType {
  """
  ClusterId which determines in which region a match was played. One region has
  multiple clusters. When selecting your region in the Dota 2 client, a random
  cluster is provided to you for each match for load balancing purposes.
  """
  id: Int

  """RegionId gives the exact geographical area where the match is played."""
  regionId: Short
}

type ConstantQuery {
  hero(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    id: Short!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): HeroType
  heroes(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [HeroType]

  """List of all the roles types for heroes."""
  roles: [RoleType]

  """Find item details by item id. id is a required input field."""
  item(
    """
    The item id to include in this query, excluding all results that do not have this item.
    """
    id: Int!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): ItemType

  """Find item details by item id. id is a required input field."""
  items(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [ItemType]

  """Find ability details by ability id. id is a required input field."""
  ability(
    """
    The ability id to include in this query, excluding all results that do not have this ability.
    """
    id: Int!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): AbilityType

  """Find ability details."""
  abilities(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    language: Language
  ): [AbilityType]

  """
  Returns a list of game mode types which is directly supplied by Dota 2. Matches API call will have a input for this value.
  """
  gameModes: [GameModeType]

  """
  Returns a list of lobby types which are mirrored from the Dota 2 client.
  """
  lobbyTypes: [LobbyTypeType]

  """
  Provided directly from Dota 2 Region files, the cluster is the geographically breakdown of where the game is played.
  """
  clusters: [ClusterType]

  """Returns a list of region details and an Id for reference."""
  regions: [RegionType]

  """
  Find game version details by game version id. id is a required input field.
  """
  gameVersion(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    id: Short!
  ): GameVersionType

  """Find game version details."""
  gameVersions: [GameVersionType]

  """Find npc details by npc id. id is a required input field."""
  npc(
    """
    The npc id to include in this query, excluding all results that do not have this npc.
    """
    id: Short!

    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short
  ): NpcType

  """Find npc details."""
  npcs(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVersionId: Short
  ): [NpcType]

  """
  Find all patch notes for each item and ability. These are found when you hover over each object in-game.
  """
  patchNotes(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    languageId: Language
  ): [PatchNoteLanguageType]

  """
  Find all abilities that are used in custom events. For example Aghnims Labyrinth.
  """
  customAbilities(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    languageId: Language
  ): [AbilityCustomGameType]

  """
  Find all modifiers that are used in the game. If you find a bug on a modifier,
  let us know as we have to control this ourselves.
  """
  modifiers(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [ModifierType]

  """Find all players who Valve qualifies as a Pro Player or Streamer."""
  proSteamAccounts: [ProSteamAccountType]
}

enum Damage {
  PHYSICAL
  MAGICAL
  PURE
}

"""
The `DateTime` scalar type represents a date and time. `DateTime` expects
timestamps to be formatted in accordance with the
[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
"""
scalar DateTime

type DeathDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  target: Short
  byAbility: Short
  byItem: Short
  goldFed: Int
  xpFed: Int
  timeDead: Int
  reliableGold: Int
  unreliableGold: Int
  positionX: Int
  positionY: Int
  goldLost: Int
  assist: [Int]
  isWardWalkThrough: Boolean
  isAttemptTpOut: Boolean
  isDieBack: Boolean
  isBurst: Boolean
  isEngagedOnDeath: Boolean
  hasHealAvailable: Boolean
  isTracked: Boolean
  isFeed: Boolean
}

scalar Decimal

input DeleteProSteamAccountRequestType {
  steamAccountId: Long
  name: String
  realName: String
}

type DireTide2020CustomGameHeroWinDayType {
  day: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
  candyScored: Int!
}

type DireTide2020CustomGameMatchType {
  id: Long
  didRadiantWin: Boolean
  durationSeconds: Short
  startDateTime: Long
  endDateTime: Long
  clusterId: Short
  replaySalt: Long
  candyLost: Short
  candyPickedUp: Short
  candyScored: Short
  radiantCandyScored: Short
  direCandyScored: Short
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [DireTide2020CustomGamePlayerType]
}

type DireTide2020CustomGamePlayerType {
  matchId: Long
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isVictory: Boolean!
  heroId: Short
  hero: HeroType
  kills: Byte
  deaths: Byte
  assists: Byte
  leaverStatus: Byte
  numLastHits: Short
  goldPerMinute: Short
  goldSpent: Int
  level: Byte
  heroDamage: Int
  heroHealing: Int
  networth: Int
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short

  """
  The item id of the dedicated neutral item slot (7.24 and after). From game
  versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
  """
  neutral0Id: Short
  partyId: Byte
  candyLost: Short
  candyPickedUp: Short
  candyScored: Short
}

type DotaMutation {
  yogurt: YogurtMutation
  user: DotaUserMutation
  admin: AdminMutation
}

type DotaNextQuery {
  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  enemy(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!

    """
    A steam account id found on your team to include in this query, excluding
    all results that do not include this steam account id found on your team.
    """
    matchSteamAccountId: Long!
  ): [DotaNextWithAllyType]

  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  ally(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!

    """
    A steam account id found on your team to include in this query, excluding
    all results that do not include this steam account id found on your team.
    """
    matchSteamAccountId: Long!
  ): [DotaNextWithAllyType]

  """
  Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users.
  """
  playerHero(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: Long!

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: Byte!

    """
    An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
    """
    lobbyTypeIds: Byte!

    """
    An array of item ids to include in this query, excluding all results that do not include one of these item ids.
    """
    limitByItemIds: Int!

    """
    The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
    """
    startDateTime: Long!
  ): [[MatchPlayerItemPurchaseEventType]]
}

type DotaNextWithAllyType {
  steamAccountId: Long
  lifetimeMatchCount: Int
  lifetimeWinMatchCount: Int
}

type DotaPlusWeekType {
  week: Long
  active: Int
  expired: Int
}

type DotaQuery {
  """Find match details by the match id. id is a required input field."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): MatchType

  """Find match details for each match id. ids is a required input field."""
  matches(
    """An array of Dota match ids to include in this query."""
    ids: [Long]!
  ): [MatchType]

  """Find player details by steam account id. id is a required input field."""
  player(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): PlayerType

  """
  Find player details for each steam account id. ids is a required input field.
  """
  players(
    """
    An array of steam account ids to limit the query to only return matches with these steam account ids.
    """
    steamAccountIds: [Long]!
  ): [PlayerType]

  """
  Find player details for each steam account id. ids is a required input field.
  """
  team(
    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamId: Int!
  ): TeamType

  """
  Results in a list of team objects that contain data about them and their players.
  """
  teams(
    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamIds: [Int]!
  ): [TeamType]

  """Find league details by league Id. Id is a required field."""
  league(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    id: Int!
  ): LeagueType

  """Find league details by searching for leagues using a LeagueRequest."""
  leagues(request: LeagueRequestType!): [LeagueType]

  """
  For getting access to one specific Guild which was used at the start of TI10 Compendium.
  """
  guild(
    """
    A guild id to include in this query, excluding all results that do not have this guild id.
    """
    id: Int!
  ): GuildType

  """
  Queries used for Stratz Yogurt - users won't be able to access these calls until they have access to the app.
  """
  yogurt: YogurtQuery

  """Queries used to populate Stratz Plus."""
  plus: PlusQuery

  """Stratz specific queries."""
  stratz: StratzQuery

  """Queries used to gain insights into hero data and statistics."""
  heroStats: HeroStatsQuery

  """Queries used to query constants in Dota."""
  constants: ConstantQuery

  """Queries used to get leaderboard information."""
  leaderboard: LeaderboardQuery

  """Queries used to find live match data."""
  live: LiveQuery

  """Queries used by 3rd party applications."""
  vendor: VendorQuery
}

type DotaSubscription {
  matchCount: TotalMatchCountType
  playerCount: TotalPlayerCountType
  feedLive: LiveEventType
  matchLive(matchId: Long!): MatchLiveType
  matchLiveLeague(leagueId: Int!): MatchLiveType
}

type DotaUserMutation {
  """Marks the user's LastReadFeedTime to the current time."""
  readAllFeed: Boolean

  """Validates a user email address if the password id is correct."""
  validateEmail(
    """The password number that was sent via email."""
    code: Guid!
  ): Boolean

  """Validates a user email address if the password id is correct."""
  updateTutorial(
    """The TutorialId number of the tutorial completed."""
    tutorialId: Short!
  ): [Short]

  """Update your user to unsubscribe from Stratz emails."""
  emailUnsubscribe: UserHomepageType

  """Updates the logged in user information profile."""
  updateProfile(
    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: CaptainJackIdentityProfileUpdateRequestType!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  followPlayer(
    """The steam account of the person you wish to (un)follow."""
    steamAccountId: Long!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  unfollowPlayer(
    """The steam account of the person you wish to (un)follow."""
    steamAccountId: Long!
  ): Boolean

  """Update your user to (un)follow a specific SteamAccountId"""
  updateFollowing(
    """The steam account of the person you wish to (un)follow."""
    followedSteamAccountId: Long!

    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: UpdateFollowerRequestType!
  ): Boolean

  """
  Updates every user you are following.  This should be handled with care, as
  this overrides all your predefinded user specific settings with these settings.
  """
  updateAllFollowing(
    """
    The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings.
    """
    request: UpdateFollowerRequestType!
  ): Boolean

  """
  Gets more in-depth information about the person you are following.  This is a
  user specific request, and you can only edit yourself.
  """
  updateFollowingFavorite(
    """The steam account of the person you wish to (un)follow."""
    followedSteamAccountId: Long!

    """Should the user become a favorite."""
    isFavorite: Boolean!
  ): Boolean

  """Update your user to (un)follow a specific LeagueId"""
  followLeague(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    leagueId: Int!
  ): Boolean
  unfollowLeague(
    """
    A league id to include in this query, excluding all results that do not have this league id.
    """
    leagueId: Int!
  ): Boolean
  applyStratzApiKey(
    """There are two type of API Tokens, Data Collector and MultiKey"""
    tokenType: StratzApiType!

    """
    The desired email address of the match replay upload team. Cannot be blank or whitespace.
    """
    emailAddress: String!

    """A users Discord full Identity name."""
    discordAddress: String!

    """A user website where the data can be seen."""
    websiteAddress: String!
    description: String!
  ): Boolean
}

type ExperienceDetailType {
  time: Int!
  amount: Int!
  reason: XpReason
  positionX: Int
  positionY: Int
}

type FeedResponseType {
  data: [FeedType]
  count: Int
  date: DateTime
}

type FeedType {
  steamAccount: SteamAccountType
  league: LeagueType
  targetSteamAccountId: Long
  type: Byte
  matchId: Long
  heroId: Int!
  date: Long
  value: Int!
  didWin: Boolean
}

enum FilterDireTide2020CustomGameMatchOrderBy {
  CANDY_SCORED
  END_DATE_TIME
}

input FilterDireTide2020CustomMatchRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Long

  """The order in which the data returned will be sorted by."""
  orderBy: FilterDireTide2020CustomGameMatchOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

enum FilterHeroWinRequestGroupBy {
  HERO_ID
  ALL
}

enum FilterLeaderboardGuildOrderBy {
  BATTLE_PASS_LEVELS
  MEMBER_COUNT
  POINTS
  ID
  PREVIOUS_WEEK_RANK
}

input FilterLeaderboardGuildRequestType {
  """What field to order the data by. Enum values."""
  orderBy: FilterLeaderboardGuildOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  order: FilterOrder

  """The region where the guild was registered."""
  region: Byte

  """If the guild is current set to 50 members."""
  isFull: Boolean

  """If anyone is able to join the guild."""
  isUnlocked: Boolean

  """The minimum amount of members a guild must have."""
  minMemberCount: Byte

  """The max amount of members a guild can have."""
  maxMemberCount: Byte

  """The amount of members a guild must have."""
  memberCount: Byte

  """The language required to join the guild."""
  language: Byte

  """The guild was created before this date time (in Unix TimeStamp)."""
  createdBeforeDateTime: Long

  """The guild was created after this date time (in Unix TimeStamp)."""
  createdAfterDateTime: Long

  """The rank required to join the guild."""
  minRequiredRank: Byte

  """The rank required to join the guild."""
  maxRequiredRank: Byte

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

input FilterLeaderboardHeroRequestType {
  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-8 with 0 being unknown
  MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Byte]

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

enum FilterLeaderboardOrder {
  RECENT
  LEVEL
  FIRST
}

input FilterMatchReplayUploadRequestType {
  withEnemySteamAccount: [Long]
  withFriendHeroId: [Short]
  withEnemyHeroId: [Short]
  withFriendBannedHeroId: [Short]
  withEnemyBannedHeroId: [Short]
  byMatchId: Long
  byMatchIds: [Long]
  byMatchUploadFileName: String
  byMatchUploadUploaderCaptainJackId: Guid
  bySteamAccountId: Long
  bySteamAccountIds: [Long]
  byHeroId: [Short]
  byLeagueId: Int
  bySeriesId: Int
  bySeriesIds: [Long]
  byTeamId: Int
  byGameMode: [Int]
  byLobbyType: [Int]
  byGameVersion: [Int]
  isLeague: Boolean
  isValidated: Boolean
  isComplete: Boolean
  isActive: Boolean
  isVictory: Boolean
  isRadiant: Boolean
  filterPositionIsUs: Boolean
  filterPosition: MatchPlayerPositionType
  filterPositionOrder: [MatchPlayerTeamPickOrderType]
  isRadiantFirstPick: Boolean
  firstPick: Boolean
  minDuration: Int
  maxDuration: Int
  minGameVersionId: Int
  maxGameVersionId: Int
  startDateTime: Long
  endDateTime: Long
  skip: Int
  take: Int
}

enum FilterOrder {
  ASC
  DESC
}

enum FilterOrderBy {
  LAST_MATCH_TIME
  ID
  NONE
  START_DATE_THEN_TIER
  LAST_MATCH_TIME_THEN_TIER
}

input FilterSearchRequestType {
  """
  The term used to define the search parameters. Minimum input is 2 characters.
  """
  query: String!

  """
  Searching our entire database can take time. If you already know what your
  searching for you, you can limit the query down to a set of specific types. (0
  - Playuers, 1 - Matches, 2 - Leagues, 3 - Teams, 4 - ProPlayers, 5 - Casters).
  Default is all types.
  """
  searchType: [Search]

  """
  The minimum rank a player must have to be allowed inside the search query.
  """
  minimumRank: Int

  """
  The maximum rank a player must have to be allowed inside the search query.
  """
  maximumRank: Int

  """
  The minimum amount of time in which a user must have played a game to be
  allowed inside the search query. A unix timestamp.
  """
  lastMatchPlayedAgo: Long

  """
  The leaderboard is split into 4 regions. The user must appear in this
  region(s) for them to be allowed inside the search query.
  """
  leaderboardRegionIds: [Byte]

  """
  When searching for a league, the tier the league must be in. Tiers: Amateur =
  1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5
  """
  leagueTierIds: [LeagueTier]

  """
  When searching for a team, only return results of those teams of which are considered Professionals.
  """
  teamIsPro: Boolean

  """The amount to have returned in your query."""
  take: Int
}

input FilterSeasonLeaderboardRequestType {
  query: String
  leaderBoardDivision: LeaderboardDivision
  heroId: Short
  position: MatchPlayerPositionType

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int

  """The amount to have returned in your query."""
  take: Int
}

input FilterSeriesRequestType {
  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

enum FilterTI2020CustomGameMatchOrderBy {
  DURATION
  END_DATE_TIME
}

input FilterTI2020HeroCompositionRequestType {
  """The base level of difficulty"""
  difficulty: TI2020CustomGameMatchDifficultyType!

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

input FilterTI2020MatchRequestType {
  """Return Matches that only include the set of Match Ids provided."""
  matchIds: [Long]

  """Return matches that only include this single player."""
  steamAccountId: Long

  """Required that the team playing the game won."""
  didWin: Boolean

  """How far into the game (levels) they completed."""
  depth: Byte

  """The base level of difficulty"""
  difficulty: TI2020CustomGameMatchDifficultyType

  """The team had to make it at least this far (level)."""
  minDepth: Byte

  """The max must be played in this list of regions"""
  regionIds: [Byte]

  """
  The game must of been played before this set time. In Unix Time Stamp Format.
  """
  createdBeforeDateTime: Long

  """
  The game must of been played after this set time. In Unix Time Stamp Format.
  """
  createdAfterDateTime: Long

  """The order in which the data returned will be sorted by."""
  orderBy: FilterTI2020CustomGameMatchOrderBy

  """If the return should be ordered by Ascending or Desending order."""
  orderDirection: FilterOrder

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
  seasonId: Byte
}

enum FindMatchPlayerGroupBy {
  HERO
  FACTION
  KILLS
  DEATHS
  ASSISTS
  IS_LEAVER
  LEVEL
  IS_PARTY
  IS_RANDOM
  LANE
  ROLE
  IS_INTENTIONAL_FEEDING
  AWARD
  ROAM_LANE
  IS_VICTORY
  DURATION_MINUTES
  CLUSTER
  REGION
  LOBBY_TYPE
  IS_LEAGUE
  IS_SERIES
  GAME_MODE
  IS_STATS
  GAME_VERSION
  TEAM
  HERO_PERFORMANCE
}

enum FindMatchPlayerList {
  ALL
  SINGLE
}

enum FindMatchPlayerOrderBy {
  DESC
  ASC
}

type FollowerType {
  captainJackIdentityId: Guid
  steamAccountId: Long
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  isFavorite: Boolean
  lastEmail: Long
  didManualUpdate: Boolean!
  steamAccount: SteamAccountType
  captainJackIdentity: CaptainJackIdentityType
}

enum GameModeEnumType {
  NONE
  ALL_PICK
  CAPTAINS_MODE
  RANDOM_DRAFT
  SINGLE_DRAFT
  ALL_RANDOM
  INTRO
  THE_DIRETIDE
  REVERSE_CAPTAINS_MODE
  THE_GREEVILING
  TUTORIAL
  MID_ONLY
  LEAST_PLAYED
  NEW_PLAYER_POOL
  COMPENDIUM_MATCHMAKING
  CUSTOM
  CAPTAINS_DRAFT
  BALANCED_DRAFT
  ABILITY_DRAFT
  EVENT
  ALL_RANDOM_DEATH_MATCH
  SOLO_MID
  ALL_PICK_RANKED
  TURBO
  MUTATION
}

type GameModeType {
  id: Short
  name: String
}

type GameVersionType {
  id: Short
  name: String
  asOfDateTime: Long
}

type GoldDetailType {
  time: Int!
  amount: Int!
  reason: GoldReason
  npcId: Int
  isValidForStats: Boolean
}

enum GoldReason {
  OTHER
  DEATH
  BUY_BACK
  ABADONS
  SELLS
  STRUCTURES
  HEROES
  CREEPS
  NEUTRAL
  ROSHAN
  COURIERS
  BOUNTY
  DOOM_DEVOURER
  WARD_DESTRUCTION
}

scalar Guid

type GuildMemberType {
  guildId: Int
  steamAccountId: Int
  joinDateTime: Long
  guild: GuildType
  steamAccount: SteamAccountType
  winCount: Int
  matchCount: Int
  imp: Int
}

type GuildType {
  id: Int
  motd: String
  name: String
  tag: String
  createdDateTime: Long
  language: Byte
  flags: Int
  logo: String
  region: Byte
  description: String
  requiredRank: Byte
  primaryColor: Byte
  secondaryColor: Byte
  pattern: Byte
  points: Int
  pastWeeklyRank: Int
  pastWeeklyPercentile: Byte
  currentPercentile: Byte
  lastUpdateDateTime: Long
  members: [GuildMemberType]
  matches(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [MatchType]
  memberCount: Byte
  totalBattlePassLevels: Int
  rank: Byte
}

type HealDetailType {
  time: Int!
  attacker: Short
  target: Short
  value: Int
  byAbility: Short
  byItem: Short
}

type HeroAbilityTalentType {
  heroId: Int!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  abilityId: Int!
  count: Long
  wins: Long
  time: Long
  winsAverage: Decimal
  timeAverage: Decimal
}

type HeroAbilityType {
  slot: Byte
  gameVersionId: Short
  abilityId: Short
  ability: AbilityType
}

type HeroDamageDetailType {
  time: Int!
  attacker: Short
  target: Short
  value: Int!
  byAbility: Short
  byItem: Short
  damageType: Damage
  fromNpc: Short
  toNpc: Short
  fromIllusion: Boolean
  toIllusion: Boolean
  isPhysicalAttack: Boolean
  isSourceMainHero: Boolean
  isTargetMainHero: Boolean
}

type HeroDotaPlusLeaderboardRankType {
  heroId: Short
  steamId: Long
  level: Byte
  totalActions: Long
  createdDateTime: Long
  steamAccount: SteamAccountType
}

type HeroDryadType {
  heroId: Short
  with: [HeroStatsHeroDryadType]
  matchCountWith: Long
  vs: [HeroStatsHeroDryadType]
  matchCountVs: Long
}

type HeroGuideListType {
  heroId: Short
  matchCount: Int

  """Guides are auto-generated of games that are successful in a game."""
  guides(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [HeroGuideType]
}

type HeroGuideType {
  heroId: Short
  steamAccountId: Long
  matchId: Long
  match: MatchType
  matchPlayer: MatchPlayerType
  createdDateTime: Long
}

type HeroHighPerformanceMatchObjectType {
  matchId: Long
  endDateTime: Long
  imp: Int!
}

type HeroHighPerformancePlayerObjectType {
  steamId: Long
  endDateTime: Long
  imp: Int!
  playerName: String!
}

type HeroHighPerformanceRampageObjectType {
  matchId: Long
  endDateTime: Long
  time: Int!
  playerName: String!
  steamId: Long
}

type HeroHighPerformanceType {
  heroId: Int!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  rampages: [HeroHighPerformanceRampageObjectType]
  matches: [HeroHighPerformanceMatchObjectType]
  players: [HeroHighPerformancePlayerObjectType]
  items: HeroPurchasePatternType
}

type HeroItemBootPurchaseObjectType {
  itemId: Int!
  instance: Int!
  time: Long
  timeAverage: Decimal
  count: Long
  wins: Long
  winAverage: Decimal
  kills: Long
  killsAverage: Decimal
  deaths: Long
  deathsAverage: Decimal
  assists: Long
  assistsAverage: Decimal
  goldEarned: Long
  goldEarnedAverage: Decimal
  xp: Long
  xpAverage: Decimal
  activations: Long
  activationsAverage: Decimal
  activationTime: Long
  activationsTimeAverage: Decimal
}

type HeroItemBootPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  events: [HeroItemBootPurchaseObjectType]
  count: Long
}

type HeroItemPurchaseObjectType {
  itemId: Int!
  instance: Int!
  time: Long
  count: Long
  wins: Long
  winsAverage: Decimal
}

type HeroItemPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  events: [HeroItemPurchaseObjectType]
  count: Long
}

type HeroItemStartingPurchaseObjectType {
  itemId: Int!
  instance: Int!
  wasGiven: Boolean!
  count: Long
  wins: Long
  winsAverage: Decimal
}

type HeroItemStartingPurchaseType {
  heroId: Int!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  events: [HeroItemStartingPurchaseObjectType]
  count: Long
}

type HeroLanguageType {
  displayName: String
  lore: String
  hype: String
}

type HeroMatchupType {
  advantage: [HeroDryadType]
  disadvantage: [HeroDryadType]
}

type HeroMetaTrendType {
  heroId: Int!
  win: [Long]
  pick: [Long]
  ban: [Long]
}

type HeroPositionDetailType {
  position: MatchPlayerPositionType
  count: Long
  wins: Decimal
  kills: Decimal
  deaths: Decimal
  assists: Decimal
  cs: Decimal
  dn: Decimal
  heroDamage: Decimal
  towerDamage: Decimal
}

type HeroPositionTimeDetailAverageObjectType {
  time: Int!
  matchCount: Long
  remainingMatchCount: Int
  wins: Decimal
  mvp: Decimal
  topCore: Decimal
  topSupport: Decimal
  courierKills: Decimal
  apm: Decimal
  casts: Decimal
  abilityCasts: Decimal
  kills: Decimal
  deaths: Decimal
  assists: Decimal
  networth: Decimal
  xp: Decimal
  cs: Decimal
  dn: Decimal
  neutrals: Decimal
  heroDamage: Decimal
  towerDamage: Decimal
  physicalDamage: Decimal
  magicalDamage: Decimal
  physicalDamageReceived: Decimal
  magicalDamageReceived: Decimal
  tripleKill: Decimal
  ultraKill: Decimal
  rampage: Decimal
  godLike: Decimal
  disableCount: Decimal
  disableDuration: Decimal
  stunCount: Decimal
  stunDuration: Decimal
  slowCount: Decimal
  slowDuration: Decimal
  healingSelf: Decimal
  healingAllies: Decimal
  invisibleCount: Decimal
  runePower: Decimal
  runeBounty: Decimal
  level: Decimal
  campsStacked: Decimal
  supportGold: Decimal
  purgeModifiers: Decimal
  ancients: Decimal
  teamKills: Decimal
  goldLost: Decimal
  goldFed: Decimal
  buybackCount: Decimal
  weakenCount: Decimal
  weakenDuration: Decimal
  physicalItemDamage: Decimal
  magicalItemDamage: Decimal
  healingItemSelf: Decimal
  healingItemAllies: Decimal
  xpFed: Decimal
  pureDamageReceived: Decimal
  attackDamage: Decimal
  castDamage: Decimal
  damageReceived: Decimal
  damage: Decimal
  pureDamage: Decimal
  kDAAverage: Decimal
  killContributionAverage: Decimal
  stompWon: Decimal
  stompLost: Decimal
  comeBackWon: Decimal
  comeBackLost: Decimal
}

type HeroPositionTimeDetailAverageType {
  heroId: Short!
  week: Int!
  bracketBasic: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  events: [HeroPositionTimeDetailAverageObjectType]
}

type HeroPurchasePatternType {
  startingItems: HeroItemStartingPurchaseType
  earlyGame: HeroItemPurchaseType
  midGame: HeroItemPurchaseType
  lateGame: HeroItemPurchaseType
}

type HeroRatingObjectType {
  heroId1: Int!
  heroId2: Int
  heroId3: Int
  pickRate: Decimal
  winRate: Decimal
  banRate: Decimal
}

type HeroRatingType {
  single: [HeroRatingObjectType]
  dryad: [HeroRatingObjectType]
}

type HeroRoleType {
  roleId: Short
  level: Short
}

type HeroStatsHeroDryadType {
  heroId1: Short
  heroId2: Short
  week: Int
  bracketBasic: RankBracketHeroTimeDetail
  count: Long
  kills: Long
  deaths: Long
  assists: Long
  networth: Long
  duration: Long
  wins: Long
  firstBloodTime: Long
  cs: Long
  dn: Long
  goldEarned: Long
  xp: Long
  heroDamage: Long
  towerDamage: Long
  heroHealing: Long
  level: Long
  synergy: Decimal
  winsAverage: Decimal
}

type HeroStatsQuery {
  """Detailed output of data per minute for each hero."""
  stats(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
    groupByTime: Boolean
    groupByPosition: Boolean
    groupByBracket: Boolean

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event after 10:00 mark in-game. Minimum input value is 0.
    """
    minTime: Int

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event before 10:00 mark in-game Maximum input value is 75.
    """
    maxTime: Int
  ): [HeroPositionTimeDetailAverageType]

  """Hero Data and statistics listed by what lane the hero plays in."""
  position(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event after 10:00 mark in-game. Minimum input value is 0.
    """
    minTime: Int

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event before 10:00 mark in-game Maximum input value is 75.
    """
    maxTime: Int
  ): [HeroPositionDetailType]

  """
  Returns back a list of the hero matchups, showing how that hero's win rate is affected with or against other heroes.
  """
  matchUp(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    Id representing how to order dryads and triads. Synergy is STRATZ formula to
    help determine the best outcome of wins and picks in one. Accepted Inputs :
    Synergy = 0, Pick = 1, Win = 2, Loss = 3, Disadvantage = 4, Advantage = 5
    """
    orderBy: Byte

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [HeroDryadType]

  """
  Used in STRATZ Hero Page. Includes Starting items and full items based in groupings of 0-14 minutes, 15-34 minutes and 35+
  """
  purchasePattern(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): HeroPurchasePatternType

  """
  Returns the items purchased for the selected hero. Adjusting the time adjusts
  the purchase amount. Shows win rate by item timings.
  """
  itemFullPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event after 10:00 mark in-game. Minimum input value is 0.
    """
    minTime: Int

    """
    Integer in minutes which determines the start of the data. For example, 10
    would result in every event before 10:00 mark in-game Maximum input value is 75.
    """
    maxTime: Int

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int
  ): HeroItemPurchaseType

  """
  This snapshots all items in the inventory of a hero at -00:30.   It tracks if an item was given or purchased.
  """
  itemStartingPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): HeroItemStartingPurchaseType

  """
  The purchase Item Components for a Hero's Boots.  Tracks things like activations or uses throughout the game.
  """
  itemBootPurchase(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): HeroItemBootPurchaseType

  """
  This call is used in Hero Of the Day.  It shows recent Rampages, High Performance and Good Players on the selected hero.
  """
  highPerformance(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): HeroHighPerformanceType

  """
  This is used on the Hero page to show the comparison of skill with the
  selected hero with other heroes.  It includes our Synergy and our Advantage
  formulas to ensure that a hero with a high win rate isn't simply just on the
  top of all the fields.
  """
  heroVsHeroMatchup(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """Minimum amount of MatchCount required for a Duo to qualify"""
    matchLimit: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): HeroMatchupType

  """
  This is used on the Hero page to show the comparison of all Hero Talents with the selected hero.
  """
  talent(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]
  ): [HeroAbilityTalentType]

  """
  Used on the Heroes page, includes a small subset of Single Heroes, Dryads and
  Triads.  Includes Win Rate, Pick Rate, Ban Rate.
  """
  ratings(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: Short!

    """
    The week to include in this query, excluding all results that do not include
    this week. The value is an epoc TimeStamp of the week of data you want.
    Leaving null gives the current week.
    """
    week: Long

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketBasicIds: [RankBracketHeroTimeDetail]

    """
    Id representing how to order dryads and triads. Synergy is STRATZ formula to
    help determine the best outcome of wins and picks in one. Accepted Inputs :
    Synergy = 0, Pick = 1, Win = 2, Loss = 3, Disadvantage = 4, Advantage = 5
    """
    positionIds: Byte
  ): HeroRatingType

  """Used on the Heroes page, for determining popular hero trends."""
  metaTrend(
    """
    Epoc TimeStamp of the day of data you want the data to start. Leaving null
    gives the current day. Will include the last 14 days with it. The 14th
    object in each array will be this day you have specificed.
    """
    day: Long
  ): [HeroMetaTrendType]

  """
  Returns the last 12 hours by hour showing the amount of matches and the amount of wins by hero id.
  """
  winHour(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinHourType]

  """
  Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id.
  """
  winDay(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinDayType]

  """
  Returns the last 12 weeks by week showing the amount of matches and the amount of wins by hero id.
  """
  winWeek(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinWeekType]

  """
  Returns the data by month showing the amount of matches and the amount of wins by hero id.
  """
  winMonth(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinMonthType]

  """
  Returns the data by game version showing the amount of matches and the amount of wins by hero id.
  """
  winGameVersion(
    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-8 with 0 being
    unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
    """
    bracketIds: [RankBracket]

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionIds: [MatchPlayerPositionType]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]

    """
    Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
    """
    groupBy: FilterHeroWinRequestGroupBy
  ): [HeroWinGameVersionType]
  guide(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    withHeroId: Short

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    againstHeroId: Short

    """
    Determines that the query require the results come with a player that is qualified as a Pro.
    """
    isPro: Boolean

    """
    An array of positions ids (enum MatchPlayerPositionType) to include in this
    query, excluding all results that do not include one of these lanes.
    """
    positionId: MatchPlayerPositionType

    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [HeroGuideListType]
}

type HeroStatType {
  enabled: Boolean
  heroUnlockOrder: Float
  team: Boolean
  cMEnabled: Boolean
  newPlayerEnabled: Boolean
  attackType: String
  startingArmor: Float
  startingMagicArmor: Float
  startingDamageMin: Float
  startingDamageMax: Float
  attackRate: Float
  attackAnimationPoint: Float
  attackAcquisitionRange: Float
  attackRange: Float
  primaryAttribute: String
  strengthBase: Float
  strengthGain: Float
  intelligenceBase: Float
  intelligenceGain: Float
  agilityBase: Float
  agilityGain: Float
  mpRegen: Float
  moveSpeed: Float
  moveTurnRate: Float
  hpBarOffset: Float
  visionDaytimeRange: Float
  visionNighttimeRange: Float
  complexity: Byte
}

type HeroTalentType {
  abilityId: Short
  slot: Byte
}

type HeroType {
  id: Short
  name: String
  displayName: String
  shortName: String
  aliases: [String]
  gameVersionId: Short
  abilities: [HeroAbilityType]
  roles: [HeroRoleType]
  language: HeroLanguageType
  talents: [HeroTalentType]
  stats: HeroStatType
}

type HeroWinDayType {
  day: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HeroWinGameVersionType {
  gameVersionId: Short!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HeroWinHourType {
  hour: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HeroWinMonthType {
  month: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HeroWinWeekType {
  week: Long!
  heroId: Short!
  winCount: Int!
  matchCount: Int!
}

type HomepageHeroDryadType {
  mainHeroId: Short
  comparisonHeroId: Short
  bracketBasic: RankBracketHeroTimeDetail
  matchCount: Long
  winCount: Long
  synergy: Decimal
  winsAverage: Decimal
  comparisonHeroBaseWinRate: Decimal
}

type HomepageHeroSynergyType {
  mainHeroId: Short
  mainHeroBaseWinRate: Decimal
  heroDryads: [HomepageHeroDryadType]
}

type ImpGeneratorMatchPlayerType {
  winChance: [Float]
  winRateByPlayerMinuteValues: [[Float]]
  events: [[ImpGeneratorPlayerEventType]]
  impValues: [[Int]]
}

input ImpGeneratorPlayerEventRequestType {
  time: Byte!
  kills: UShort!
  deaths: UShort!
  assists: UShort!
  cs: UShort!
  dn: UShort!
  level: Byte!
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  damageReceived: Int!
  healingAllies: Int!
  runePower: Int!
  neutrals: Int!
}

type ImpGeneratorPlayerEventType {
  time: Byte
  kills: UShort
  deaths: UShort
  assists: UShort
  cs: UShort
  dn: UShort
  level: Byte
  physicalDamage: Int
  magicalDamage: Int
  pureDamage: Int
  damageReceived: Int
  healingAllies: Int
  runePower: Int
  neutrals: Int
}

input ImpGeneratorPlayerRequestType {
  heroId: Short!
  bracket: RankBracket!
  position: MatchPlayerPositionType!
  events: [ImpGeneratorPlayerEventRequestType]!
}

type ImpGeneratorPlayerType {
  winChance: [Float]
  winRateByPlayerMinuteValues: [[Float]]
  events: [ImpGeneratorPlayerEventType]
  impValues: [[Int]]
}

input ImpGeneratorRequestType {
  bans: [Short]!
  players: [ImpGeneratorPlayerRequestType]!
  isTurbo: Boolean!
}

input ImportPickBanType {
  playerSlot: Byte
  isPick: Boolean!
  heroId: Short
  time: Byte
  isRadiant: Boolean
  order: Byte
  wasBannedSuccessfully: Boolean
}

type ImpQuery {
  """
  Returns details about all players in a specific match and details regarding Imp
  """
  matchGenerator(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): ImpGeneratorMatchPlayerType

  """
  Returns details about a specific player in a game with certains events.
  """
  playerGenerator(request: ImpGeneratorRequestType!): ImpGeneratorPlayerType
}

type InventoryObjectType {
  itemId: Short
  charges: Int
  secondaryCharges: Int
}

type InventoryType {
  time: Int!
  item0: InventoryObjectType
  item1: InventoryObjectType
  item2: InventoryObjectType
  item3: InventoryObjectType
  item4: InventoryObjectType
  item5: InventoryObjectType
  backPack0: InventoryObjectType
  backPack1: InventoryObjectType
  backPack2: InventoryObjectType
  teleport0: InventoryObjectType
  neutral0: InventoryObjectType
}

type ItemAttributeType {
  name: String
  value: String
}

type ItemComponentType {
  index: Byte
  componentId: Short
}

type ItemLanguageType {
  displayName: String
  description: [String]
  lore: [String]
  notes: [String]
  attributes: [String]
}

type ItemPurchaseType {
  time: Int!
  itemId: Short
}

type ItemStatType {
  behavior: Long
  unitTargetType: Long
  unitTargetTeam: Long
  unitTargetFlags: Long
  fightRecapLevel: Byte
  castRange: [Int]
  castPoint: [Float]
  cooldown: [Float]
  manaCost: [Float]
  channelTime: [Float]
  sharedCooldown: String
  cost: Int
  shopTags: String
  aliases: String
  quality: String
  isSellable: Boolean
  isDroppable: Boolean
  isPurchasable: Boolean
  isSideShop: Boolean
  isStackable: Boolean
  isPermanent: Boolean
  isHideCharges: Boolean
  isRequiresCharges: Boolean
  isDisplayCharges: Boolean
  isSupport: Boolean
  isAlertable: Boolean
  isTempestDoubleClonable: Boolean
  stockMax: Short
  initialCharges: Short
  initialStock: Short
  stockTime: Int
  initialStockTime: Short
  isRecipe: Boolean
  needsComponents: Boolean
  upgradeItem: Short
  upgradeRecipe: Short
  itemResult: Short
}

type ItemType {
  id: Short
  name: String
  displayName: String
  shortName: String
  isSupportFullItem: Boolean
  language: ItemLanguageType
  stat: ItemStatType
  attributes: [ItemAttributeType]
  components: [ItemComponentType]
  image: String
}

type ItemUsedEventType {
  time: Int!
  itemId: Short
  attacker: Short
  target: Short
}

type KillDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  target: Short
  byAbility: Short
  byItem: Short
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  assist: [Int]
  isSolo: Boolean
  isGank: Boolean
  isInvisible: Boolean
  isSmoke: Boolean
  isTpRecently: Boolean
  isRuneEffected: Boolean
}

enum Language {
  ENGLISH
  BRAZILIAN
  BULGARIAN
  CZECH
  DANISH
  DUTCH
  FINNISH
  FRENCH
  GERMAN
  GREEK
  HUNGARIAN
  ITALIAN
  JAPANESE
  KOREAN
  KOREANA
  NORWEGIAN
  POLISH
  PORTUGUESE
  ROMANIAN
  RUSSIAN
  S_CHINESE
  SPANISH
  SWEDISH
  T_CHINESE
  THAI
  TURKISH
  UKRAINIAN
}

type LanguageType {
  id: Byte!
  languageCode: String
  languageName: String
}

type LastHitDetailType {
  time: Int!
  attacker: Short
  isFromIllusion: Boolean
  npcId: Short
  byAbility: Short
  byItem: Short
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  isCreep: Boolean
  isNeutral: Boolean
  isAncient: Boolean
  mapLocation: MapLocationEnums
}

enum LeaderboardDivision {
  AMERICAS
  SE_ASIA
  EUROPE
  CHINA
}

type LeaderboardQuery {
  """Returns the list of the current season leaderboard."""
  season(request: FilterSeasonLeaderboardRequestType): [SteamAccountSeasonActiveLeaderboardRankType]

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short

    """
    Id representing how to order the dota plus leader board. Accepted values are
    Recent = 0 (Shows the most recent awards given) and Level = 1 (shows by the
    highest level first)
    """
    orderBy: FilterLeaderboardOrder

    """Only returns players of this level."""
    level: Byte

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): PlayerHeroDotaPlusLeaderboardRankResponseType

  """Gets the top player of DotaPlus order by Level and Time Achived."""
  dotaPlusTopLevels: [HeroDotaPlusLeaderboardRankType]

  """Show amount of active and expired DotaPlus users by Week"""
  dotaPlusWeek: [DotaPlusWeekType]

  """Gets the current leaderboard for Battle Pass levels."""
  battlePass(
    """The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."""
    eventId: Byte

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): PlayerBattlePassResponseType

  """Gets the current leaderboard for all coaches by level."""
  coaching(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): PlayerCoachingLeaderboardResponseType

  """Gets the current leaderboard for all guilds by points."""
  guild(request: FilterLeaderboardGuildRequestType): [GuildType]

  """
  Gets the current leaderboard for all players by a specific Hero, order by IMP.
  """
  hero(request: FilterLeaderboardHeroRequestType): [PlayerLeaderBoardByHeroType]
}

type LeagueBattlePassType {
  count: Int
  average: Int
}

input LeagueMatchesRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Long

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of stage type ids to include in this query, excluding all results that do not include one of these stage types.
  """
  leagueStageTypeIds: [LeagueStage]

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int!

  """The amount of matches to have returned in your query. Max 1000"""
  take: Int!
}

type LeagueMetaDetailType {
  heroId: Short
  winCount: Int
  lossCount: Int
  winRate: Decimal
  pickRate: Decimal
  pickCount: Int
  banRate: Decimal
  banCount: Int
}

type LeagueMetaType {
  leagueId: Int
  bestRecord: LeagueMetaDetailType
  mostPicked: LeagueMetaDetailType
  mostBanned: LeagueMetaDetailType
  missingMatchCount: Int
  totalMatchCount: Int
  league: LeagueType
}

enum LeagueNodeDefaultGroupEnum {
  INVALID
  BEST_OF_ONE
  BEST_OF_THREE
  BEST_OF_FIVE
  BEST_OF_TWO
}

type LeagueNodeGroupType {
  id: Short
  name: String
  parentNodeGroupId: Short
  advancingNodeGroupId: Short
  advancingTeamCount: Byte
  teamCount: Byte
  defaultNodeType: LeagueNodeDefaultGroupEnum
  nodeGroupType: LeagueNodeGroupTypeEnum
  round: Byte
  maxRounds: Byte
  isTieBreaker: Boolean
  isFinalGroup: Boolean
  isCompleted: Boolean
  phase: Byte
  region: Byte
  startDate: Long
  endDate: Long
  secondaryAdvancingNodeGroupId: Short
  secondaryAdvancingTeamCount: Byte
  tertiaryAdvancingNodeGroupId: Short
  tertiaryAdvancingTeamCount: Byte
  eliminationDPCPoints: Int
  nodes: [LeagueNodeType]
}

enum LeagueNodeGroupTypeEnum {
  INVALID
  ORGANIZATIONAL
  ROUND_ROBIN
  SWISS
  BRACKET_SINGLE
  BRACKET_DOUBLE_SEED_LOSER
  BRACKET_DOUBLE_ALL_WINNER
  SHOWMATCH
  GSL
}

type LeagueNodeType {
  nodeGroupId: Short
  id: Short
  name: String
  winningNodeId: Short
  losingNodeId: Short
  nodeType: LeagueNodeDefaultGroupEnum
  scheduledTime: Long
  actualTime: Long
  seriesId: Long
  matches: [MatchType]
  teamOneId: Int
  teamOne: TeamType
  teamTwoId: Int
  teamTwo: TeamType
  teamOneWins: Byte
  teamTwoWins: Byte
  hasStarted: Boolean
  isCompleted: Boolean
  streamIds: [Int]
  streams: [LeagueStreamType]
}

type LeaguePrizePoolPercentageType {
  leagueId: Int
  index: Byte
  percentage: Int
}

enum LeagueRegion {
  UNSET
  NA
  SA
  EUROPE
  CIS
  CHINA
  SEA
}

type LeagueRegisteredPlayerType {
  leagueId: Int
  league: LeagueType
  teamId: Int
  radiantTeam: TeamType
  steamAccountId: Long
  steamAccount: SteamAccountType
}

input LeagueRequestType {
  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  An array of league ids to include in this query, excluding all results that do not include one of these leagues.
  """
  leagueIds: [Int]

  """
  An array of tier ids to include in this query, excluding all results that do not include one of these tiers.
  """
  tiers: [LeagueTier]

  """Whether an image is required or not, represented in a boolean."""
  requireImage: Boolean

  """Whether a prize pool is required or not, represented in a boolean."""
  requirePrizePool: Boolean

  """
  Whether a start and end date is required or not, represented in a boolean.
  """
  requireStartAndEndDates: Boolean

  """Whether a league has live matches or not, represented in a boolean."""
  hasLiveMatches: Boolean

  """Whether a league has ended or not, represented in a boolean."""
  leagueEnded: Boolean

  """Whether a league has started or not, represented in a boolean."""
  isFutureLeague: Boolean

  """If a league is set to start after this time."""
  startDateTime: Long

  """If a league is set to end before this time."""
  endDateTime: Long

  """
  Determine to Start value of finding a League Between two specific datetimes.
  """
  betweenStartDateTime: Long

  """
  Determine to End value of finding a League Between two specific datetimes.
  """
  betweenEndDateTime: Long

  """The id to order the results by in this query."""
  orderBy: FilterOrderBy

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int

  """The amount to have returned in your query."""
  take: Int
}

enum LeagueStage {
  OPEN_QUALIFERS
  CLOSED_QUALIFERS
  CHAMPIONS_QUALIFERS
  GROUP_STAGE
  MAIN_EVENT
}

type LeagueStatType {
  matchCount: Int
  radiantWinMatchCount: Int
  averageMatchDurationSeconds: Int
}

type LeagueStreamType {
  id: Int
  languageId: Language
  name: String
  broadcastProvider: Byte
  streamUrl: String
  vodUrl: String
}

type LeagueTableHeroLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

type LeagueTableHeroOverviewType {
  matchCount: Int!
  matchWins: Int!
  pickPhaseOne: Int!
  pickPhaseTwo: Int!
  pickPhaseThree: Int!
  banCount: Int!
  banPhaseOne: Int!
  banPhaseTwo: Int!
  banPhaseThree: Int!
}

type LeagueTableHeroStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  killContribution: Float!
}

type LeagueTableHeroType {
  heroId: Short
  overview: LeagueTableHeroOverviewType
  stats: LeagueTableHeroStatsType
  heroes: [LeagueTableHeroStatsType]
  lanes: [LeagueTableHeroLanesObjectType]
}

type LeagueTablePlayerHeroesObjectType {
  heroId: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Int!
}

type LeagueTablePlayerLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

type LeagueTablePlayerOverviewType {
  points: Float
  earnings: Float
  seriesCount: Int!
  seriesWins: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Int!
}

type LeagueTablePlayerStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  killContribution: Float!
}

type LeagueTablePlayerType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  overview: LeagueTablePlayerOverviewType
  stats: LeagueTablePlayerStatsType
  heroes: [LeagueTablePlayerHeroesObjectType]
  lanes: [LeagueTablePlayerLanesObjectType]
}

type LeagueTableTeamHeroesObjectType {
  heroId: Int!
  matchCount: Int!
  matchWins: Int!
  imp: Decimal
  banCount: Int
}

type LeagueTableTeamLanesObjectType {
  id: Byte
  matchCount: Int!
  matchWins: Int!
}

type LeagueTableTeamOverviewType {
  points: Float
  earnings: Float
  seriesCount: Int!
  seriesWins: Int!
  seriesDraws: Int!
  matchCount: Int!
  matchWins: Int!
  tmp: Float
}

type LeagueTableTeamStatsType {
  kills: Float!
  deaths: Float!
  assists: Float!
  cs: Float!
  gpm: Float!
  xpm: Float!
  heal: Float!
  heroDamage: Float!
  towerDamage: Float!
  duration: Float!
}

type LeagueTableTeamType {
  teamId: Int
  team: TeamType
  members: [LeagueRegisteredPlayerType]
  overview: LeagueTableTeamOverviewType
  stats: LeagueTableTeamStatsType
  heroes: [LeagueTableTeamHeroesObjectType]
  lanes: [LeagueTableTeamLanesObjectType]
}

type LeagueTableType {
  leagueId: Int!
  tableTeams: [LeagueTableTeamType]
  tableHeroes: [LeagueTableHeroType]
  tablePlayers: [LeagueTablePlayerType]
}

enum LeagueTier {
  UNSET
  AMATEUR
  PROFESSIONAL
  MINOR
  MAJOR
  INTERNATIONAL
  DPC_QUALIFIER
  DPC_LEAGUE_QUALIFIER
  DPC_LEAGUE
  DPC_LEAGUE_FINALS
}

type LeagueType {
  id: Int
  name: String
  banner: String
  basePrizePool: Int
  stopSalesTime: DateTime
  tier: LeagueTier
  region: LeagueRegion
  private: Boolean
  freeToSpectate: Boolean
  startDateTime: Long
  endDateTime: Long
  tournamentUrl: String
  lastMatchDate: Long
  modifiedDateTime: Long
  hasLiveMatches: Boolean
  prizePool: Int
  imageUri: String
  displayName: String
  description: String
  country: String
  venue: String
  isFollowed: Boolean
  nodeGroups: [LeagueNodeGroupType]
  liveMatches: [MatchLiveType]
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: LeagueMatchesRequestType!
  ): [MatchType]
  series(
    """
    When searching for league matches, an array of the stage type ids the match
    must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions
    Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]

    """
    A team id to include in this query, excluding all results that do not have this team id.
    """
    teamId: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [SeriesType]
  tables(
    """
    When searching for league matches, an array of the stage type ids the match
    must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions
    Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]

    """
    To modify the values of Kills, Deaths, Assists, etc.  Accepted inputs are Average (default), Highest, Lowest, Median.
    """
    calculateTypeId: TableCalculateEnum
  ): LeagueTableType
  battlePass: LeagueBattlePassType
  stats(
    """
    When searching for league matches, an array of the stage type ids the match
    must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions
    Qualifers = 3, Group Stage = 4, Main Event = 5
    """
    leagueStageTypeIds: [LeagueStage]
  ): LeagueStatType
  prizePoolPercentages: [LeaguePrizePoolPercentageType]
  standings: [TeamPrizeType]
  streams: [LeagueStreamType]
}

type LiveEventMatchDireTide2020StompType {
  match: DireTide2020CustomGameMatchType
}

type LiveEventPlayerDireTide2020CandyScoredType {
  steamAccount: SteamAccountType
  match: DireTide2020CustomGameMatchType
  heroId: Short
  candyScored: Short
}

type LiveEventPlayerHeroAssistsType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  assistCount: Byte
}

type LiveEventPlayerHeroBuildingDamageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  buildingDamage: Int
}

type LiveEventPlayerHeroDewardType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  dewardCount: Byte
}

type LiveEventPlayerHeroDotaPlusLevelType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  level: Byte
}

type LiveEventPlayerHeroExpPerMinuteType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  expPerMinute: Short
}

type LiveEventPlayerHeroGoldPerMinuteType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  goldPerMinute: Short
}

type LiveEventPlayerHeroHealingType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  healingAmount: Int
}

type LiveEventPlayerHeroHeroDamageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  heroDamage: Int
}

type LiveEventPlayerHeroHighImpType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  imp: Byte
}

type LiveEventPlayerHeroItemPurchaseType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  itemId: Short
  itemCount: Byte
}

type LiveEventPlayerHeroKillsType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  killCount: Byte
}

type LiveEventPlayerHeroWinStreakType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  winStreakCount: Byte
}

type LiveEventPlayerRampageType {
  steamAccount: SteamAccountType
  match: MatchType
  heroId: Short
  rampageCount: Byte
}

type LiveEventPlayerRankUpType {
  steamAccount: SteamAccountType
  match: MatchType
  rank: Byte
}

type LiveEventPlayerWinStreakType {
  steamAccount: SteamAccountType
  match: MatchType
  winStreakCount: Byte
}

type LiveEventProPlayerLiveType {
  steamAccounts: [SteamAccountType]
  match: MatchLiveType
}

union LiveEventType = LiveEventPlayerRampageType | LiveEventPlayerWinStreakType | LiveEventPlayerHeroWinStreakType | LiveEventPlayerHeroKillsType | LiveEventPlayerHeroAssistsType | LiveEventPlayerHeroBuildingDamageType | LiveEventPlayerHeroHealingType | LiveEventPlayerHeroHeroDamageType | LiveEventPlayerHeroGoldPerMinuteType | LiveEventPlayerHeroExpPerMinuteType | LiveEventPlayerHeroHighImpType | LiveEventPlayerHeroDotaPlusLevelType | LiveEventPlayerRankUpType | LiveEventProPlayerLiveType | LiveEventPlayerHeroItemPurchaseType | LiveEventPlayerHeroDewardType | LiveEventMatchDireTide2020StompType | LiveEventPlayerDireTide2020CandyScoredType

type LiveQuery {
  """
  Find a live match by match id. A live match is data where a match is on the
  Dota watch list and still active. All League games are also Live. id is a
  required input field.
  """
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!

    """
    The amount in seconds you wish to skip until you start getting MatchEvents
    or PlayerMatchEvents. When requesting reply data back, you may only want the
    updates from X second on. This will skip the first set of seconds and give
    everything after this time.
    """
    skipPlaybackDuration: Int
  ): MatchLiveType

  """
  Find all live matches. A live match is data where a match is on the Dota watch
  list and still active. All League games are also Live.
  """
  matches(request: MatchLiveRequestType): [MatchLiveType]
}

type LobbyTypeType {
  id: Int!
  name: String
}

scalar Long

enum MapLocationEnums {
  RADIANT_BASE
  RADIANT_OFF_LANE
  RADIANT_MID_LANE
  RADIANT_SAFE_LANE
  DIRE_BASE
  DIRE_OFF_LANE
  DIRE_MID_LANE
  DIRE_SAFE_LANE
  RIVER
  ROSHAN
  ROAMING
  RADIANT_FOUNTAIN
  DIRE_FOUNTAIN
}

type MatchesDayType {
  day: Long!
  matchCount: Int!
}

type MatchesGameVersionType {
  gameVersionId: Short!
  matchCount: Int!
}

type MatchesHourType {
  hour: Long!
  matchCount: Int!
}

type MatchesMonthType {
  month: Long!
  matchCount: Int!
}

type MatchesWeekType {
  week: Long!
  matchCount: Int!
}

type MatchGroupByType {
  id: Long
  matchCount: Int
  winCount: Int
  avgImp: Int
  avgGoldPerMinute: Int
  avgExperiencePerMinute: Int
  avgKDA: Float
  lastDateTime: Long
}

enum MatchLaneType {
  ROAMING
  SAFE_LANE
  MID_LANE
  OFF_LANE
  JUNGLE
  UNKNOWN
}

type MatchLiveBuildingDetailType {
  time: Int!
  indexId: Int
  type: BuildingType
  isAlive: Boolean!
  positionX: Int
  positionY: Int
  isRadiant: Boolean
  npcId: Int
}

enum MatchLiveGameState {
  INIT
  WAIT_FOR_PLAYERS_TO_LOAD
  HERO_SELECTION
  STRATEGY_TIME
  PRE_GAME
  GAME_IN_PROGRESS
  POST_GAME
  DISCONNECT
  TEAM_SHOWCASE
  CUSTOM_GAME_SETUP
  WAIT_FOR_MAP_TO_LOAD
  LAST
}

type MatchLiveInsightType {
  teamOneVsWinCount: Int!
  teamTwoVsWinCount: Int!
  teamOneLeagueWinCount: Int!
  teamOneLeagueMatchCount: Int!
  teamTwoLeagueWinCount: Int!
  teamTwoLeagueMatchCount: Int!
  lastSeries: [SeriesType]
}

type MatchLivePickBanType {
  isPick: Boolean!
  heroId: Short
  order: Int
  bannedHeroId: Short
  isRadiant: Boolean
  baseWinRate: Float
  adjustedWinRate: Float
  letter: PlusLetterType
  positionValues: [Float]
  winRateValues: [Float]
  durationValues: [Float]
  position: MatchPlayerPositionType
}

type MatchLivePlaybackDataType {
  roshanEvents: [MatchLiveRoshanDetailType]
  buildingEvents: [MatchLiveBuildingDetailType]
  pickBans: [MatchLivePickBanType]
  radiantScore: [MatchLiveTeamScoreDetailType]
  direScore: [MatchLiveTeamScoreDetailType]
}

type MatchLivePlayerAssistDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerDeathDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerDenyDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerExperienceDetailType {
  time: Int!
  expPerMinute: Int!
}

type MatchLivePlayerGoldDetailType {
  time: Int!
  gold: Int!
  networth: Int!
  networthDifference: Int!
  goldPerMinute: Int!
}

type MatchLivePlayerImpDetailType {
  time: Int!
  imp: Short!
}

type MatchLivePlayerInventoryDetailType {
  time: Int!
  itemId0: Short
  itemId1: Short
  itemId2: Short
  itemId3: Short
  itemId4: Short
  itemId5: Short
  backpackId0: Short
  backpackId1: Short
  backpackId2: Short
}

type MatchLivePlayerKillDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerLastHitDetailType {
  time: Int!
  positionX: Int!
  positionY: Int!
}

type MatchLivePlayerLevelDetailType {
  time: Int!
  level: Int!
}

type MatchLivePlayerPositionDetailType {
  time: Int!
  x: Int!
  y: Int!
}

type MatchLivePlayerType {
  matchId: Long
  heroId: Short
  hero: HeroType
  name: String
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isRadiant: Boolean
  numKills: Byte
  numDeaths: Byte
  numAssists: Byte
  leaverStatus: Byte
  numLastHits: UShort
  numDenies: UShort
  goldPerMinute: UShort
  experiencePerMinute: UShort
  level: Byte
  gold: Int
  goldSpent: Int
  heroDamage: Int
  towerDamage: Int
  itemId0: Short
  itemId1: Short
  itemId2: Short
  itemId3: Short
  itemId4: Short
  itemId5: Short
  backpackId0: Short
  backpackId1: Short
  backpackId2: Short
  playbackData: MatchPlayerLivePlaybackDataType
  networth: Int
  respawnTimer: Short
  ultimateCooldown: Short
  ultimateState: Short
  impPerMinute: [MatchLivePlayerImpDetailType]
  gameVersionId: Short
  baseWinRateValue: Float
  position: MatchPlayerPositionType
}

enum MatchLiveRequestOrderBy {
  GAME_TIME
  MATCH_ID
  SPECTATOR_COUNT
}

input MatchLiveRequestType {
  """
  The hero id to include in this query, excluding all results that do not include this hero.
  """
  heroId: Short

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  Returns only matches that are currently still being updated by the backend.
  """
  isParsing: Boolean

  """
  Returns only matches that are no longer active and completed but not yet deleted.
  """
  isCompleted: Boolean

  """
  An array of league ids to include in this query, excluding all results that do not include one of these leagues.
  """
  leagueIds: [Int]

  """
  Only return Live Matches In Progress that are currently in these states.
  """
  gameStates: [MatchLiveGameState]

  """
  An array of tier ids to include in this query, excluding all results that do not include one of these tiers.
  """
  tiers: [LeagueTier]

  """
  Playback Data can contain a lot of information. This will only display the most recent event for each of the fields.
  """
  lastPlaybackEventOnly: Boolean

  """If the return should be ordered by Ascending or Desending order."""
  orderBy: MatchLiveRequestOrderBy

  """The amount to have returned in your query."""
  take: Int

  """The amount to skip before collecting your query. Hint: Paging"""
  skip: Int
}

type MatchLiveRoshanDetailType {
  time: Int
  isAlive: Boolean
  respawnTimer: Int
}

type MatchLiveTeamScoreDetailType {
  time: Int
  score: Short
}

type MatchLiveType {
  matchId: Long
  radiantScore: Byte
  direScore: Byte
  leagueId: Int
  league: LeagueType
  delay: Short
  spectators: Int
  averageRank: Int
  buildingState: Long
  radiantLead: Int
  lobbyId: Long
  lobbyType: Byte
  serverSteamId: String
  gameTime: Int
  completed: Boolean
  isUpdating: Boolean
  isParsing: Boolean
  radiantTeamId: Int
  direTeamId: Int
  radiantTeam: TeamType
  direTeam: TeamType
  parseBeginGameTime: Int
  numHumanPlayers: Byte
  gameMode: Int
  playbackData: MatchLivePlaybackDataType
  gameState: MatchLiveGameState
  gameMinute: Short
  players: [MatchLivePlayerType]
  createdDateTime: Long
  modifiedDateTime: Long
  insight: MatchLiveInsightType
  winRateValues: [Float]
  durationValues: [Float]
  liveWinRateValues: [MatchLiveWinRateDetailType]
}

type MatchLiveWinRateDetailType {
  time: Int!
  winRate: Float!
}

type MatchmakingStatsType {
  time: Long!
  uSWest: Int!
  uSEast: Int!
  europe: Int!
  singapore: Int!
  brazil: Int!
  stockholm: Int!
  austria: Int!
  australia: Int!
  southAfrica: Int!
  perfectWorldTelecom: Int!
  perfectWorldUnicom: Int!
  dubai: Int!
  chile: Int!
  peru: Int!
  india: Int!
  perfectWorldTelecomGuangdong: Int!
  perfectWorldTelecomZhejiang: Int!
  japan: Int!
  perfectWorldTelecomWuhan: Int!
  taiwan: Int!
  perfectWorldUnicomTianjin: Int!
}

type MatchPlaybackDataBuildingEventType {
  time: Int!
  indexId: Int
  type: BuildingType
  hp: Int
  maxHp: Int
  positionX: Int
  positionY: Int
  isRadiant: Boolean
  npcId: Int
  didShrineActivate: Boolean
}

type MatchplaybackDataCourierEventObjectType {
  time: Int!
  positionX: Int
  positionY: Int
  hp: Int
  isFlying: Boolean
  respawnTime: Int
  didCastBoost: Boolean
  item0Id: Int
  item1Id: Int
  item2Id: Int
  item3Id: Int
  item4Id: Int
  item5Id: Int
}

type MatchPlaybackDataCourierEventType {
  id: Int!
  ownerHero: Int
  isRadiant: Boolean
  events: [MatchplaybackDataCourierEventObjectType]
}

type MatchPlaybackDataRoshanEventType {
  time: Int!
  hp: Int
  maxHp: Int
  createTime: Int
  x: Int
  y: Int
  totalDamageTaken: Int
  item0: Int
  item1: Int
  item2: Int
  item3: Int
  item4: Int
  item5: Int
}

type MatchPlaybackDataRuneEventType {
  indexId: Int!
  time: Int!
  positionX: Int!
  positionY: Int!
  fromPlayer: Int!
  location: Int!
  rune: Int!
  action: Int!
}

type MatchPlaybackDataTowerDeathEventType {
  time: Int!
  radiant: Int!
  dire: Int!
}

type MatchPlaybackDataType {
  courierEvents: [MatchPlaybackDataCourierEventType]
  runeEvents: [MatchPlaybackDataRuneEventType]
  wardEvents: [MatchPlaybackDataWardEventType]
  buildingEvents: [MatchPlaybackDataBuildingEventType]
  towerDeathEvents: [MatchPlaybackDataTowerDeathEventType]
  roshanEvents: [MatchPlaybackDataRoshanEventType]
  radiantCaptainSteamAccountId: Long
  radiantCaptainSteamAccount: SteamAccountType
  direCaptainSteamAccountId: Long
  direCaptainSteamAccount: SteamAccountType
}

type MatchPlaybackDataWardEventType {
  indexId: Int!
  time: Int!
  positionX: Int!
  positionY: Int!
  fromPlayer: Int
  wardType: Byte
  action: Byte
}

type MatchPlayerAdditionalUnitType {
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short
  neutral0Id: Short
}

enum MatchPlayerAward {
  NONE
  MVP
  TOP_CORE
  TOP_SUPPORT
}

type MatchPlayerHeroDamageSourceAbilityReportObjectType {
  abilityId: Int!
  count: Int!
  amount: Int!
}

type MatchPlayerHeroDamageSourceItemReportObjectType {
  itemId: Int!
  count: Int!
  amount: Int!
}

type MatchPlayerHeroDamageTargetReportObjectType {
  target: Int!
  amount: Int!
}

type MatchPlayerHeroDamageTotalRecievedReportObjectType {
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  heal: Int!
  stunCount: Int!
  stunDuration: Int!
  disableCount: Int!
  disableDuration: Int!
  slowCount: Int!
  slowDuration: Int!
}

type MatchPlayerHeroDamageTotalReportObjectType {
  physicalDamage: Int!
  magicalDamage: Int!
  pureDamage: Int!
  selfHeal: Int!
  allyHeal: Int!
  stunCount: Int!
  stunDuration: Int!
  disableCount: Int!
  disableDuration: Int!
  slowCount: Int!
  slowDuration: Int!
}

type MatchPlayerInventoryObjectType {
  itemId: Int!
  charges: Int
  secondaryCharges: Int
}

type MatchPlayerInventoryType {
  item0: MatchPlayerInventoryObjectType
  item1: MatchPlayerInventoryObjectType
  item2: MatchPlayerInventoryObjectType
  item3: MatchPlayerInventoryObjectType
  item4: MatchPlayerInventoryObjectType
  item5: MatchPlayerInventoryObjectType
  backPack0: MatchPlayerInventoryObjectType
  backPack1: MatchPlayerInventoryObjectType
  backPack2: MatchPlayerInventoryObjectType
  neutral0: MatchPlayerInventoryObjectType
}

type MatchPlayerItemPurchaseEventType {
  time: Int!
  itemId: Int!
}

type MatchPlayerLivePlaybackDataType {
  positionEvents: [MatchLivePlayerPositionDetailType]
  goldEvents: [MatchLivePlayerGoldDetailType]
  levelEvents: [MatchLivePlayerLevelDetailType]
  killEvents: [MatchLivePlayerKillDetailType]
  deathEvents: [MatchLivePlayerDeathDetailType]
  assistEvents: [MatchLivePlayerAssistDetailType]
  csEvents: [MatchLivePlayerLastHitDetailType]
  denyEvents: [MatchLivePlayerDenyDetailType]
  experienceEvents: [MatchLivePlayerExperienceDetailType]
  inventoryEvents: [MatchLivePlayerInventoryDetailType]
}

type MatchPlayerPlaybackDataType {
  abilityLearnEvents: [AbilityLearnEventsType]
  abilityUsedEvents: [AbilityUsedEventsType]
  abilityActiveLists: [AbilityActiveListType]
  itemUsedEvents: [ItemUsedEventType]
  playerUpdatePositionEvents: [PlayerUpdatePositionDetailType]
  playerUpdateGoldEvents: [PlayerUpdateGoldDetailType]
  playerUpdateAttributeEvents: [PlayerUpdateAttributeDetailType]
  playerUpdateLevelEvents: [PlayerUpdateLevelDetailType]
  playerUpdateHealthEvents: [PlayerUpdateHealthDetailType]
  playerUpdateBattleEvents: [PlayerUpdateBattleDetailType]
  killEvents: [KillDetailType]
  deathEvents: [DeathDetailType]
  assistEvents: [AssistDetailType]
  csEvents: [LastHitDetailType]
  goldEvents: [GoldDetailType]
  experienceEvents: [ExperienceDetailType]
  healEvents: [HealDetailType]
  heroDamageEvents: [HeroDamageDetailType]
  towerDamageEvents: [TowerDamageDetailType]
  inventoryEvents: [InventoryType]
  purchaseEvents: [ItemPurchaseType]
  buyBackEvents: [BuyBackDetailType]
  streakEvents: [StreakEventType]
  spiritBearInventoryEvents: [SpiritBearInventoryType]
}

enum MatchPlayerPositionType {
  POSITION_1
  POSITION_2
  POSITION_3
  POSITION_4
  POSITION_5
  UNKNOWN
  FILTERED
  ALL
}

enum MatchPlayerRoleType {
  CORE
  LIGHT_SUPPORT
  HARD_SUPPORT
  UNKNOWN
}

type MatchPlayerSpectatorType {
  steamId: Long
  isRadiantCoach: Boolean
  isVictory: Boolean
}

type MatchPlayerSpiritBearInventoryType {
  item0Id: Int
  item1Id: Int
  item2Id: Int
  item3Id: Int
  item4Id: Int
  item5Id: Int
  backPack0Id: Int
  backPack1Id: Int
  backPack2Id: Int
  neutral0Id: Int
}

type MatchPlayerStatsAbilityCastObjectType {
  target: Int!
  count: Int!
  damage: Int!
  duration: Int
}

type MatchPlayerStatsAbilityCastReportType {
  abilityId: Int!
  count: Int!
  targets: [MatchPlayerStatsAbilityCastObjectType]
}

type MatchPlayerStatsActionReportType {
  moveToPosition: Int!
  moveToTarget: Int!
  attackPosition: Int!
  attackTarget: Int!
  castPosition: Int!
  castTarget: Int!
  castNoTarget: Int!
  heldPosition: Int!
  glyphCast: Int!
  scanUsed: Int!
  pingUsed: Int!
}

type MatchPlayerStatsAllTalkEventType {
  time: Int!
  message: String
  pausedTick: Int!
}

type MatchPlayerStatsAssistEventType {
  time: Int!
  target: Int
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
}

type MatchPlayerStatsBuffEventType {
  time: Int!
  abilityId: Int
  itemId: Int
  stackCount: Int
}

type MatchPlayerStatsChatWheelEventType {
  time: Int!
  chatWheelId: Short
}

type MatchPlayerStatsCourierKillEventType {
  time: Int!
  positionX: Int
  positionY: Int
}

type MatchPlayerStatsDeathEventType {
  time: Int!
  attacker: Short
  target: Int
  byAbility: Int
  byItem: Int
  goldFed: Int
  xpFed: Int
  timeDead: Int
  positionX: Int
  positionY: Int
  goldLost: Int
  assist: [Int!]
  isWardWalkThrough: Boolean
  isAttemptTpOut: Boolean
  isDieBack: Boolean
  isBurst: Boolean
  isEngagedOnDeath: Boolean
  hasHealAvailable: Boolean
  isTracked: Boolean
}

type MatchPlayerStatsFarmDistributionObjectType {
  id: Int!
  count: Int!
  gold: Int
  xp: Int
}

type MatchPlayerStatsFarmDistributionReportType {
  creepType: [MatchPlayerStatsFarmDistributionObjectType]
  creepLocation: [MatchPlayerStatsFarmDistributionObjectType]
  neutralLocation: [MatchPlayerStatsFarmDistributionObjectType]
  ancientLocation: [MatchPlayerStatsFarmDistributionObjectType]
  buildings: [MatchPlayerStatsFarmDistributionObjectType]
  buyBackGold: Int!
  abandonGold: Int!
  bountyGold: MatchPlayerStatsFarmDistributionObjectType
  talentGold: Int!
  other: [MatchPlayerStatsFarmDistributionObjectType]
  itemGold: Int!
}

type MatchPlayerStatsHeroDamageReportType {
  dealtTotal: MatchPlayerHeroDamageTotalReportObjectType
  receivedTotal: MatchPlayerHeroDamageTotalRecievedReportObjectType
  dealtTargets: [MatchPlayerHeroDamageTargetReportObjectType]
  receivedTargets: [MatchPlayerHeroDamageTargetReportObjectType]
  dealtSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
  receivedSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
  dealtSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
  receivedSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
}

type MatchPlayerStatsItemUsedEventType {
  itemId: Int!
  count: Int
}

type MatchPlayerStatsKillEventType {
  time: Int!
  target: Int
  byAbility: Int
  byItem: Int
  gold: Int
  xp: Int
  positionX: Int
  positionY: Int
  assist: [Int!]
  isSolo: Boolean
  isGank: Boolean
  isInvisible: Boolean
  isSmoke: Boolean
  isTpRecently: Boolean
}

type MatchPlayerStatsLocationReportType {
  positionX: Int!
  positionY: Int!
}

type MatchPlayerStatsRuneEventType {
  time: Int!
  rune: RuneEnums
  action: RuneAction
  gold: Int
  positionX: Int
  positionY: Int
}

type MatchPlayerStatsTowerDamageReportType {
  npcId: Int!
  damage: Int!
}

type MatchPlayerStatsType {
  matchId: Long
  steamAccountId: Long
  gameVersionId: Short
  level: [Int]
  killEvents: [MatchPlayerStatsKillEventType]
  killCount: Int
  deathEvents: [MatchPlayerStatsDeathEventType]
  deathCount: Int
  assistEvents: [MatchPlayerStatsAssistEventType]
  assistCount: Int
  lastHitsPerMinute: [Int]
  lastHitCount: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  goldPerMinute: [Int]
  goldCount: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  experiencePerMinute: [Int]
  experienceCount: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  healPerMinute: [Int]
  healCount: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  heroDamagePerMinute: [Int]
  heroDamageCount: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  towerDamagePerMinute: [Int]
  towerDamageCount: Int
  towerDamageReport: [MatchPlayerStatsTowerDamageReportType]
  courierKills: [MatchPlayerStatsCourierKillEventType]
  wards: [MatchPlayerStatsWardEventType]
  itemPurchases: [MatchPlayerItemPurchaseEventType]
  itemUsed: [MatchPlayerStatsItemUsedEventType]
  allTalks: [MatchPlayerStatsAllTalkEventType]
  chatWheels: [MatchPlayerStatsChatWheelEventType]
  actionsPerMinute: [Int]
  actionReport: MatchPlayerStatsActionReportType
  invisibleSeconds: Int
  locationReport: [MatchPlayerStatsLocationReportType]
  farmDistributionReport: [MatchPlayerStatsFarmDistributionReportType]
  runes: [MatchPlayerStatsRuneEventType]
  abilityCastReport: [MatchPlayerStatsAbilityCastReportType]
  heroDamageReport: MatchPlayerStatsHeroDamageReportType
  inventoryReport: [MatchPlayerInventoryType]

  """
  Starts at minute 0:00 and Index 0 will show the Networth at 0:00 in the game.
  """
  networthPerMinute: [Int]

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  campStack: [Int]
  matchPlayerBuffEvent: [MatchPlayerStatsBuffEventType]

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  deniesPerMinute: [Int]

  """
  Starts at minute 0:00.  The last index will contain the last subset of data,
  so if a match is 41:01 long, the last index will be the change in the last 1 second.
  """
  impPerMinute: [Int]

  """
  Starts at minute 0:00.  The last index will contain the last subset of data,
  so if a match is 41:01 long, the last index will be the change in the last 1 second.
  """
  impPerMinute2: [Int]
  dotaPlusHeroXp: Int

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  tripsFountainPerMinute: [Int]
  spiritBearInventoryReport: [MatchPlayerSpiritBearInventoryType]
  abilities(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVerionId: Int
  ): [PlayerAbilityType]

  """
  Starts at minute 0:00.  Each index contains the data for that minute. Index 0 has everything from 0:00 to 0:59.
  """
  heroDamageReceivedPerMinute: [Int]
}

type MatchPlayerStatsWardEventType {
  time: Int!
  type: Int!
  positionX: Int
  positionY: Int
}

enum MatchPlayerTeamPickOrderType {
  FIRST_PICK
  SECOND_PICK
  THIRD_PICK
  FOURTH_PICK
  FIFTH_PICK
}

type MatchPlayerType {
  matchId: Long
  match: MatchType
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isRadiant: Boolean
  isVictory: Boolean
  heroId: Short
  gameVersionId: Short
  hero: HeroType
  kills: Byte
  deaths: Byte
  assists: Byte
  leaverStatus: Byte
  numLastHits: Short
  numDenies: Short
  goldPerMinute: Short
  networth: Int
  experiencePerMinute: Short
  level: Byte
  gold: Int
  goldSpent: Int
  heroDamage: Int
  towerDamage: Int
  heroHealing: Int
  partyId: Byte
  isRandom: Boolean
  lane: Byte
  streakPrediction: Byte
  intentionalFeeding: Boolean
  role: Byte
  roleBasic: Byte
  imp: Short
  award: Byte
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short

  """
  The item id of the dedicated neutral item slot (7.24 and after). From game
  versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
  """
  neutral0Id: Short
  behavior: Short
  stats: MatchPlayerStatsType
  playbackData: MatchPlayerPlaybackDataType
  heroAverage: [HeroPositionTimeDetailAverageObjectType]
  additionalUnit: MatchPlayerAdditionalUnitType

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus: [HeroDotaPlusLeaderboardRankType]
}

type MatchReplayUploadHeroDuoSummaryType {
  heroId: Short
  winCountWith: Int!
  winCountAgainst: Int!
  matchCountWith: Int!
  matchCountAgainst: Int!
}

type MatchReplayUploadHeroSummaryType {
  heroId: Short
  winCountWith: Int!
  winCountAgainst: Int!
  matchCountWith: Int!
  matchCountAgainst: Int!
  banCountWith: Int!
  banCountAgainst: Int!
  duos: [MatchReplayUploadHeroDuoSummaryType]
}

type MatchReplayUploadMatchType {
  matchUploadTeamId: Int!
  id: Long
  fileName: String!
  uploaderCaptainJackIdentityId: Guid
  isValidated: Boolean!
  isComplete: Boolean!
  isActive: Boolean!
  didRadiantWin: Boolean!
  durationSeconds: Short
  durationMinutes: Int!
  startDateTime: DateTime
  endDateTime: DateTime
  lobbyType: Byte
  numHumanPlayers: Byte
  numHumanSpectators: Byte
  leagueId: Int
  seriesId: Long
  gameMode: Byte
  radiantTeamId: Int
  radiantKills: Byte
  direTeamId: Int
  direKills: Byte
  isRadiantFirstPick: Boolean!
  gameVersionId: Int!
  notes: String
  players: [MatchReplayUploadPlayerType]
  stats: MatchReplayUploadStatsType
  radiantTeam: TeamType
  direTeam: TeamType
  league: LeagueType
}

type MatchReplayUploadOverviewType {
  matchCount: Int!
  winCount: Int!
  matches: [MatchReplayUploadMatchType]
}

type MatchReplayUploadPickBanType {
  playerSlot: Byte
  isPick: Boolean!
  heroId: Short
  bannedHeroId: Short
  time: Byte
  isRadiant: Boolean
  order: Byte
  wasBannedSuccessfully: Boolean!
}

type MatchReplayUploadPlayerStatsItemsType {
  item0IdList: [Byte]
  item1IdList: [Byte]
  item2IdList: [Byte]
  item3IdList: [Byte]
  item4IdList: [Byte]
  item5IdList: [Byte]
  backpack0IdList: [Byte]
  backpack1IdList: [Byte]
  backpack2IdList: [Byte]
}

type MatchReplayUploadPlayerStatsType {
  killsList: [Int]
  assistsList: [Int]
  deathsList: [Int]
  streakList: [Int]
  levelList: [Int]
  totalEarnedGoldList: [Int]
  reliableGoldList: [Int]
  unreliableGoldList: [Int]
  totalEarnedXpList: [Int]
  sharedGoldList: [Int]
  heroKillGoldList: [Int]
  creepKillGoldList: [Int]
  incomeGoldList: [Int]
  networthList: [Int]
  denyCountList: [Int]
  lastHitCountList: [Int]
  lastHitStreakList: [Int]
  lastHitMultiKillList: [Int]
  nearbyCreepDeathCountList: [Int]
  claimedDenyCountList: [Int]
  claimedMissCountList: [Int]
  missCountList: [Int]
  stunsList: [Int]
  heroHealingList: [Int]
  towerKillsList: [Int]
  roshanKillsList: [Int]
  observerWardsPlacedList: [Int]
  sentryWardsPlacedList: [Int]
  creepStackList: [Int]
  campStackList: [Int]
  runePicksupList: [Int]
  goldSpentOnSupportList: [Int]
  heroDamageList: [Int]
  wardsPurchasedList: [Int]
  wardsDestroyedList: [Int]
  commandsIssuedList: [Int]
  goldSpentOnConsumablesList: [Int]
  goldSpentOnItemsList: [Int]
  goldSpentOnBuybacksList: [Int]
  goldLostToDeathList: [Int]
  maxHealthList: [Int]
  maxManaList: [Int]
  bkbChargesUsedList: [Int]
  damageMinList: [Int]
  damageMaxList: [Int]
  damageBonusList: [Int]
  strengthTotalList: [Int]
  agilityTotalList: [Int]
  intellectTotalList: [Int]
  towerDamageList: [Int]
  items: MatchReplayUploadPlayerStatsItemsType
}

type MatchReplayUploadPlayerType {
  matchId: Long
  playerSlot: Byte
  matchUploadTeamId: Int!
  steamAccountId: Long
  isRadiant: Boolean!
  isDire: Boolean!
  teamSlot: Byte
  heroId: Short
  kills: Byte
  deaths: Byte
  assists: Byte
  networth: Int!
  lastHits: Short
  denies: Short
  goldPerMinute: Short
  experiencePerMinute: Short
  totalGoldSpent: Int!
  goldSpentOnBuybacks: Int
  goldSpentOnConsumables: Int
  goldSpentOnItems: Int
  goldSpentOnSupport: Int
  heroDamage: Int!
  towerDamage: Int!
  towerKills: Short
  heroHealing: Int!
  level: Byte
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short
  backpack0Id: Short
  backpack1Id: Short
  backpack2Id: Short
  lane: MatchLaneType
  role: MatchPlayerRoleType
  position: MatchPlayerPositionType
  pickOrder: Byte
  teamPickOrder: MatchPlayerTeamPickOrderType
  isVictory: Boolean!
  stats: MatchReplayUploadPlayerStatsType
  steamAccount: SteamAccountType
}

type MatchReplayUploadStatsType {
  spectators: [Long]
  pickBans: [MatchReplayUploadPickBanType]
}

type MatchReplayUploadTeamMemberType {
  captainJackIdentityId: Guid
  matchUploadTeamId: Int!
  isAdmin: Boolean!
  isDefaultTeam: Boolean!
  steamAccount: SteamAccountType
}

type MatchReplayUploadTeamType {
  id: Int!
  name: String!
  email: String!
  teamId: Int!
  creatorCaptainJackIdentityId: Guid
  team: TeamType
  members: [MatchReplayUploadTeamMemberType]
  isDefault: Boolean
}

type MatchStatsChatEventType {
  time: Int
  type: Int
  fromHeroId: Short
  toHeroId: Short
  value: Short
  pausedTick: Int
  isRadiant: Boolean
}

type MatchStatsLaneReportFactionLaneObject {
  meleeCount: Int!
  rangeCount: Int!
  siegeCount: Int!
  denyCount: Int!
  neutralCount: Int!
}

type MatchStatsLaneReportFactionObjectType {
  midLane: MatchStatsLaneReportFactionLaneObject
  offLane: MatchStatsLaneReportFactionLaneObject
  safeLane: MatchStatsLaneReportFactionLaneObject
}

type MatchStatsLaneReportType {
  radiant: [MatchStatsLaneReportFactionObjectType]
  dire: [MatchStatsLaneReportFactionObjectType]
}

type MatchStatsOutpostReportObjectType {
  npcId: Int
  isControlledByRadiant: Boolean!
  isRadiantSide: Boolean!
}

type MatchStatsPickBanType {
  isPick: Boolean!
  heroId: Short
  team: Int
  order: Int
  bannedHeroId: Short
  isRadiant: Boolean
  playerIndex: Int
  wasBannedSuccessfully: Boolean
  baseWinRate: Byte
  adjustedWinRate: Byte
  letter: Int
}

type MatchStatsTowerDeathType {
  time: Int
  npcId: Short
  isRadiant: Boolean
  attacker: Short
}

type MatchStatsTowerReportObjectType {
  npcId: Int
  hp: Int
}

type MatchStatsTowerReportType {
  towers: [MatchStatsTowerReportObjectType]
  outposts: [MatchStatsOutpostReportObjectType]
}

type MatchStatsType {
  matchId: Long

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantNetworthLeads: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantExperienceLeads: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  radiantKills: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  direKills: [Int]

  """This begins at -60 to 0 seconds (Index 0)."""
  pickBans: [MatchStatsPickBanType]
  towerStatus: [MatchStatsTowerReportType]
  laneReport: MatchStatsLaneReportType
  winRates: [Decimal]
  predictedWinRates: [Decimal]
  chatEvents: [MatchStatsChatEventType]
  towerDeaths: [MatchStatsTowerDeathType]
}

type MatchType {
  id: Long
  didRadiantWin: Boolean
  durationSeconds: Int
  startDateTime: Long
  endDateTime: Long
  towerStatusRadiant: Int
  towerStatusDire: Int
  barracksStatusRadiant: Short
  barracksStatusDire: Short
  clusterId: Int
  firstBloodTime: Int
  lobbyType: Int
  numHumanPlayers: Int
  gameMode: Int
  replaySalt: Long
  isStats: Boolean
  tournamentId: Int
  tournamentRound: Short
  actualRank: Short
  averageRank: Short
  averageImp: Short
  parsedDateTime: Long
  statsDateTime: Long
  leagueId: Int
  radiantTeamId: Int
  direTeamId: Int
  seriesId: Long
  gameVersionId: Short
  regionId: Byte
  sequenceNum: Long
  rank: Int
  bracket: Byte
  analysisOutcome: Byte
  predictedOutcomeWeight: Byte
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [MatchPlayerType]
  radiantTeam: TeamType
  direTeam: TeamType
  series: SeriesType
  stats: MatchStatsType
  playbackData: MatchPlaybackDataType
  spectators: [MatchPlayerSpectatorType]
  league: LeagueType
}

input MergeProSteamAccountRequestType {
  steamAccountId: Long
  name: String!
  realName: String
}

type ModifierType {
  id: Short
  name: String
  buffDuration: Int
  isRoot: Boolean
  isStun: Boolean
  isSilence: Boolean
  isInvisible: Boolean
  isShackle: Boolean
  isHex: Boolean
  isSleep: Boolean
  isCyclone: Boolean
  isTaunt: Boolean
  isDisarm: Boolean
  isBlind: Boolean
  isEthereal: Boolean
  isMovementSlow: Boolean
  isAttackSlow: Boolean
  isBreak: Boolean
  isArmorReduce: Boolean
  isAttackReduce: Boolean
  isMute: Boolean
  isDamageAmplified: Boolean
  isMovementDebuff: Boolean
  isKnockback: Boolean
  isWeaken: Boolean
  isItem: Boolean
  isBanished: Boolean
}

type NewsItemType {
  id: Long
  title: String!
  uri: String!
  author: String!
  contents: String!
  feedLabel: String!
  date: Long
  feedName: String!
}

type NpcStatType {
  level: Float
  statusHealth: Float
  statusHealthRegen: Float
  statusMana: Float
  statusManaRegen: Float
  movementSpeed: Float
  movementTurnRate: Float
  dayTimeVision: Float
  nightTimeVision: Float
  attackRangeBuffer: Float
  attackRange: Float
  isNeutralUnitType: Boolean
  isAncient: Boolean
  canBeDominated: Boolean
  autoAttacksByDefault: Boolean
  attackDamageMin: Float
  attackDamageMax: Float
  attackRate: Float
  attackAnimationPoint: Float
  projectileSpeed: Float
  teamName: String
  combatClassAttack: String
  combatClassDefend: String
  unitRelationshipClass: String
  attackDesire: Float
  hasInventory: Boolean
  wakesNeutrals: Boolean
}

type NpcType {
  id: Short
  name: String
  stat: NpcStatType
}

type PageAghanimQuery {
  """Returns a match by Id based on the TI10 (2020) summer event."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): TI2020CustomGameMatchType

  """Returns a list of matches by based on the TI10 (2020) summer event."""
  matches(request: FilterTI2020MatchRequestType): [TI2020CustomGameMatchType]

  """
  Returns all the combinations of Heroes and their success on the TI10 (2020) summer event.
  """
  heroCompositions(request: FilterTI2020HeroCompositionRequestType!): [TI2020CustomGameHeroCompositionType]

  """
  Returns all the combinations of Heroes and their success on the TI10 (2020) summer event.
  """
  heroComposition(heroIds: [Short]!, difficulty: TI2020CustomGameMatchDifficultyType!): TI2020CustomGameHeroCompositionType

  """
  Returns the last 3 days winrate for each hero by Difficulty in the TI10 (2020) summer event.
  """
  winRate(difficulty: TI2020CustomGameMatchDifficultyType!): TI2020CustomGameHeroWinRateType

  """Returns all the Abilities for a Hero on the TI10 (2020) summer event."""
  heroAbility(difficulty: TI2020CustomGameMatchDifficultyType!): [TI2020CustomGameHeroAbilityType]

  """
  Returns all the Room Types by Difficulty for the TI10 (2020) summer event.
  """
  room(difficulty: TI2020CustomGameMatchDifficultyType!): [TI2020CustomGameRoomType]

  """
  Returns all the Room Modifiers by Difficulty for the TI10 (2020) summer event.
  """
  roomModifier(difficulty: TI2020CustomGameMatchDifficultyType!): [TI2020CustomGameRoomModifierType]
}

type PageDireTide2020Query {
  """Returns a match by Id based on the 2020 Halloween Event DireTide."""
  match(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): DireTide2020CustomGameMatchType

  """
  Returns a list of matches by based on the 2020 Halloween Event DireTide.
  """
  matches(request: FilterDireTide2020CustomMatchRequestType): [DireTide2020CustomGameMatchType]

  """
  Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id.
  """
  winHour(
    """The amount to have returned in your query."""
    take: Int
  ): [DireTide2020CustomGameHeroWinDayType]
}

type PageMatchesQuery {
  """Returns the last 12 hours by hour showing the amount of matches."""
  matchesStatsHour(
    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-80 with 0 being
    unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesHourType]

  """Returns the last 12 days by day showing the amount of matches."""
  matchesStatsDay(
    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-80 with 0 being
    unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesDayType]

  """Returns the last 12 weeks by week showing the amount of matches."""
  matchesStatsWeek(
    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-80 with 0 being
    unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesWeekType]

  """Returns the data by month showing the amount of matches."""
  matchesStatsMonth(
    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-80 with 0 being
    unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesMonthType]

  """Returns the data by game version showing the amount of matches."""
  matchesStatsGameVersion(
    """The amount to have returned in your query."""
    take: Int

    """
    An array of rank ids to include in this query, excluding all results that do
    not include one of these ranks. The value ranges from 0-80 with 0 being
    unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
    """
    bracketIds: [RankBracket]

    """
    An array of region ids to include in this query, excluding all results that do not include one of these regions.
    """
    regionIds: [BasicRegionType]

    """
    An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
    """
    gameModeIds: [GameModeEnumType]
  ): [MatchesGameVersionType]

  """
  Amount of players who are active and searching for a game in this region.
  """
  matchmakingStats: [MatchmakingStatsType]
}

type PagePlayerQuery {
  """Returns the violations commited by a player in their last 500 games."""
  conduct: PlayerConductResponseType

  """Get very simple data for the on-hover of a player icon."""
  simpleSummary: PlayerCardHoverType

  """
  Provided in-depth look of a player and how they proform globally on all heroes.
  """
  performance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """A more in depth at a single player's single hero performance."""
  heroPerformance(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """
  Returns a list of all heroes played by the steam account id and contains data about the average performance.
  """
  heroesPerformance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroesPerformanceMatchesRequestType!
  ): [PlayerHeroesPerformanceType]

  """
  Picked the top pros and annoucers and determines if you ever have played with them and when.
  """
  playedWithPro: PlayerPlayedWithProType

  """Returns a general player summary of random set of predefinded filters."""
  breakdown(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerBreakdownRequestType!
  ): PlayerBreakdownType
}

type PagePlayersQuery {
  """
  Endpoint which breaks down all the SteamAccounts in the database by their current season rank.
  """
  steamAccountByRank: [SteamAccountByRankType]
}

type PageQuery {
  """
  STRATZ specific endpoints found on the /player/ section of the website. id is a required input field.
  """
  player(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): PagePlayerQuery

  """
  STRATZ specific endpoints found on the /players/ section of the website. 
  """
  players: PagePlayersQuery

  """
  STRATZ specific endpoints found on the /matches/ section of the website. 
  """
  matches: PageMatchesQuery

  """Endpoints for the TI10 (2020) regarding the summer event."""
  aghanim: PageAghanimQuery

  """Endpoints for Imp Related calls."""
  imp: ImpQuery
  direTide2020: PageDireTide2020Query
}

type PatchNoteLanguageType {
  id: String
  gameVersionId: Short
  languageId: Byte
  index: Byte
  abilityId: Short
  itemId: Short
  heroId: Short
  generalId: PatchNoteType
  text: String
}

enum PatchNoteType {
  HERO
  GENERAL
  GENERIC
  ITEM
}

type PlayerAbilityType {
  abilityId: Int!
  time: Int!
  level: Int!
  gameVersionId: Short
  abilityType(
    """
    The game version id to include in this query, excluding all results that do not have this game version.
    """
    gameVerionId: Int

    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityType
  isTalent: Boolean
}

type PlayerActivitySummaryHeroType {
  heroId: Int
  winCount: Int
  lossCount: Int
}

type PlayerActivitySummaryType {
  activity: PlayerBehaviorActivity
  matchCount: Int
  coreCount: Int
  supportCount: Int
  imp: Int
  heroes: [PlayerActivitySummaryHeroType]
}

type PlayerBadgeType {
  badgeId: Byte
  slot: Byte
  createdDateTime: Long
}

type PlayerBattlePassResponseType {
  players: [PlayerBattlePassType]
  playerCount: Int!
  accountsAbove2000Count: Int!
  accountsAbove1000Count: Int!
  accountsAbove500Count: Int!
  accountsAbove330Count: Int!
  accountsAbove275Count: Int!
  accountsAbove225Count: Int!
  accountsAbove195Count: Int!
  accountsAbove75Count: Int!
}

type PlayerBattlePassType {
  steamAccount: SteamAccountType
  activity: Byte
  level: Int!
}

enum PlayerBehaviorActivity {
  NONE
  VERY_LOW
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
  INTENSE
}

type PlayerBreakdownObjectType {
  id: Int
  matchCount: Int!
  win: Int
  imp: Int
  lastSeenDateTime: Long
}

input PlayerBreakdownRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerBreakdownType {
  matches: PlayerBreakdownObjectType
  isStatsMatches: [PlayerBreakdownObjectType]
  rankMatches: [PlayerBreakdownObjectType]
  lobbyMatches: [PlayerBreakdownObjectType]
  gameModeMatches: [PlayerBreakdownObjectType]
  factionMatches: [PlayerBreakdownObjectType]
  regionMatches: [PlayerBreakdownObjectType]
  laneMatches: [PlayerBreakdownObjectType]
  roleMatches: [PlayerBreakdownObjectType]
  partyMatches: [PlayerBreakdownObjectType]
  impMatches: [PlayerBreakdownObjectType]
  durationMatches: [PlayerBreakdownObjectType]
  heroAttributeMatches: [PlayerBreakdownObjectType]
  dayOfWeekMatches: [PlayerBreakdownObjectType]
  timeOfDayMatches: [PlayerBreakdownObjectType]
  weekEndMatches: [PlayerBreakdownObjectType]
}

type PlayerCardHoverHeroType {
  heroId: Int!
  winCount: Int!
  lossCount: Int!
}

type PlayerCardHoverType {
  steamAccount: SteamAccountType
  lastUpdateDateTime: Long
  matchCount: Int
  coreCount: Int
  supportCount: Int
  imp: Int
  heroes: PlayerCardHoverHeroType
  activity: Byte
}

type PlayerCoachingLeaderboardResponseType {
  players: PlayerCoachingLeaderboardType
  accounts: Int!
  accountsAbove500: Int!
  accountsAbove2500: Int!
}

type PlayerCoachingLeaderboardType {
  steamAccount: SteamAccountType
  activity: Byte
  rating: Int!
  matchCount: Int!
  winCount: Int!
  firstMatchDateTime: Long
  lastMatchDateTime: Long
}

type PlayerConductResponseType {
  lastIncidentDateTime: Long
  lastIncidentMatchId: Long
  recentMatchIncidents: [Short]
  behaviorScore: Short
}

type PlayerDraftHeroHighlightType {
  lastPlayed: Long
  winCount: Int
  matchCount: Int
  impAllTime: Int
  mvpCountLastMonth: Int
  topCoreCountLastMonth: Int
  topSupportCountLastMonth: Int
  winCountLastMonth: Int
  matchCountLastMonth: Int
  impLastMonth: Int
  winCountLastSixMonths: Int
  matchCountLastSixMonths: Int
  impLastSixMonths: Int
}

type PlayerHeroDotaPlusLeaderboardRankResponseType {
  players: [HeroDotaPlusLeaderboardRankType]
}

input PlayerHeroesPerformanceMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerHeroesPerformanceScoreType {
  id: Int!
  score: Float!
  matchCount: Int!
  winCount: Int!
  imp: Int
}

type PlayerHeroesPerformanceType {
  heroId: Short!
  hero: HeroType
  winCount: Int!
  kDA: Float
  duration: Int!
  imp: Int
  best: Float
  matchCount: Int!
  goldPerMinute: Int!
  experiencePerMinute: Int!
  laneScore: [PlayerHeroesPerformanceScoreType]
  roleScore: [PlayerHeroesPerformanceScoreType]
  lastPlayedDateTime: Long
}

input PlayerHeroPerformanceMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  Requests matches where the match is at least this many minutes. Default is null and there is no minimum.
  """
  minDuration: Int

  """
  Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum.
  """
  maxDuration: Int

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  Requests matches where the match is at least than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no minimum.
  """
  minGameVersionId: Int

  """
  Requests matches where the match is lower than this input.  See GameVersion
  API call for a list of patch ids. Default is null and there is no maximum.
  """
  maxGameVersionId: Int

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input.
  """
  partyCounts: [Int]

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerLeaderBoardByHeroType {
  heroId: Short
  seasonBracket: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  impAverage: Byte
  role: MatchPlayerRoleType
  lane: MatchLaneType
  wins: Byte
  losses: Byte
  winStreak: Byte
  regionId: Byte
  changeInRanking: Short
  createdDateTime: Long
}

input PlayerMatchesGroupByRequestType {
  """
  Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field.
  """
  groupBy: FindMatchPlayerGroupBy!

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-8 with 0 being unknown
  MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

input PlayerMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  When requesting matches with a primary SteamAccountId, this will ensure that player is on specific team Id being sent in.
  """
  teamIdSteamAccount: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-8 with 0 being unknown
  MMR and 1-8 is low to high MMR brackets. Example 7 is Divine.
  """
  bracketIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  Determines if you want a single player returned, only the player by
  SteamAccountId, or if you want all 10 players in the match.
  """
  playerList: FindMatchPlayerList

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int

  """The amount of matches to have returned in your query. Max 1000"""
  take: Int

  """Only return matches before this match id. Can be used instead of Skip."""
  before: Long

  """Only return matches after this match id. Can be used instead of Skip."""
  after: Long

  """In what order the returned data will come in."""
  orderBy: FindMatchPlayerOrderBy
}

type PlayerPerformanceCompositionHeroType {
  heroId: Short
  matchCount: Int!
  winCount: Int!
}

type PlayerPerformanceCompositionType {
  allies: [PlayerPerformanceCompositionHeroType]
  foes: [PlayerPerformanceCompositionHeroType]
}

input PlayerPerformanceMatchesRequestType {
  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  A team id to include in this query, excluding all results that do not have this team id.
  """
  teamId: Int

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """Whether the match is a league match or not."""
  isLeague: Boolean

  """Whether the match has a team assigned or not."""
  isTeam: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  When searching for a league, the tier the league must be in. Tiers: Amateur =
  1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5
  """
  tier: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """Whether the match was a victory or not for the specified player."""
  isVictory: Boolean

  """Whether the specified player was on Radiant or not."""
  isRadiant: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]
}

type PlayerPerformancePositionObjectType {
  laneType: Byte
  laneMatchCount: Int!
  laneWinCount: Int!
}

type PlayerPerformancePositionType {
  roleType: Byte
  roleMatchCount: Int!
  roleWinCount: Int!
  lanes: [PlayerPerformancePositionObjectType]
}

type PlayerPerformanceType {
  heroId: [Short]
  hero: HeroType
  matchCount: Int!
  winCount: Int!
  streak: Int!
  maxStreak: Int!
  imp: Int
  rank: Int
  mmrTier: Int!
  mmrBracket: Int!
  awardMatchCount: Int!
  mvpCount: Int!
  topCoreCount: Int!
  topSupportCount: Int!
  kills: Int
  killsAverage: Decimal
  deaths: Int
  deathsAverage: Decimal
  assists: Int
  assistsAverage: Decimal
  cs: Int
  csAverage: Decimal
  gpm: Int
  gpmAverage: Decimal
  xpm: Int
  xpmAverage: Decimal
  composition: PlayerPerformanceCompositionType
  position: [PlayerPerformancePositionType]

  """
  Contains an array of 6 items which are listed as index 0 - 1st Pick, Index 1 -
  Pick 2nd, 3rd, Index 2 - Pick 4th, 5th, Index 3 - Pick 6th, Pick 7th, Index 4
  - Pick 8th, 9ths, Index 5 - Pick 10th
  """
  pickOrder: [Int]
}

type PlayerPlayedWithProPlayerMatchType {
  matchId: Long
  date: Long
  isVictory: Boolean!
}

type PlayerPlayedWithProPlayerType {
  steamId: Long
  name: String!
  with: PlayerPlayedWithProPlayerMatchType
  vs: PlayerPlayedWithProPlayerMatchType
}

type PlayerPlayedWithProTeamType {
  teamId: Int!
  teamLogo: String!
  teamName: String!
  players: [PlayerPlayedWithProPlayerType]
}

type PlayerPlayedWithProType {
  playedCount: Int!
  totalCount: Int!
  casters: [PlayerPlayedWithProPlayerType]
  teams: [PlayerPlayedWithProTeamType]
  internationalWinners: [PlayerPlayedWithProTeamType]
}

type PlayerType {
  steamAccountId: Long
  identity: CaptainJackIdentityPublicProfileType
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int
  imp: Int
  lastMatchDate: Long
  lastMatchRegionId: Byte
  ranks(
    """An array of season in which Dota creates each year for ranks."""
    seasonRankIds: [Byte]
  ): [SteamAccountSeasonRankType]
  leaderboardRanks(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [SteamAccountSeasonLeaderBoardRankType]
  languageCodes: [String]
  badges: [PlayerBadgeType]
  names: [SteamAccountNameType]
  behaviorScore: Short
  team: SteamAccountTeamMemberType
  guildMember: GuildMemberType
  activity: PlayerActivitySummaryType
  isFollowed: Boolean
  simpleSummary: PlayerCardHoverType
  performance: PlayerPerformanceType
  heroPerformance(
    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!

    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType!
  ): PlayerPerformanceType

  """
  Returns a list of all heroes played by the steam account id and contains data about the average performance.
  """
  heroesPerformance(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerHeroPerformanceMatchesRequestType!
  ): [PlayerHeroesPerformanceType]

  """
  Picked the top pros and annoucers and determines if you ever have played with them and when.
  """
  playedWithPro: [PlayerPlayedWithProType]

  """
  Find match details by steam account id. steamAccountId is a required input field.
  """
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesRequestType!
  ): [MatchType]

  """
  Find match details by steam account id. The return is modified to group the data by the GroupBy parameter.
  """
  matchesGroupBy(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: PlayerMatchesGroupByRequestType!
  ): [MatchGroupByType]

  """
  Gets the players of Dota which have DotaPlus and have a high level hero.
  """
  dotaPlus: [HeroDotaPlusLeaderboardRankType]
}

type PlayerUpdateAttributeDetailType {
  time: Int!
  agi: Int!
  int: Int!
  str: Int!
}

type PlayerUpdateBattleDetailType {
  time: Int!
  damageMinMax: Int!
  damageBonus: Int!
  hpRegen: Int!
  mpRegen: Int!
}

type PlayerUpdateGoldDetailType {
  time: Int!
  gold: Int!
  unreliableGold: Int!
  networth: Int!
  networthDifference: Int!
}

type PlayerUpdateHealthDetailType {
  time: Int!
  hp: Int!
  maxHp: Int!
  mp: Int!
  maxMp: Int!
}

type PlayerUpdateLevelDetailType {
  time: Int!
  level: Int!
}

type PlayerUpdatePositionDetailType {
  time: Int!
  x: Int!
  y: Int!
}

input PlusDraftMissingLetterPlayerObjectType {
  """The slot of player. It is required to be in order from 0-9."""
  slot: Int!

  """
  When a player has selected a hero, this is the id. If a null is sent, we will send back a hero list of possible heroes.
  """
  heroId: Short

  """
  The rank this played is.  In the event he is anonymous, use the lowest rank player in the game.
  """
  rank: Int

  """
  The lane this player will play. If a null is sent, we will assign the best possible lane.
  """
  position: MatchPlayerPositionType

  """
  The order in which this player has picked. If a person has not picked, please send null. Send in order of 0-9.
  """
  order: Byte

  """
  To determine the missing letter, isPicking will determine the score before the
  hero was selected and after the hero is selected. Only 1 person can have
  isPicking = true.
  """
  isPicking: Boolean
}

input PlusDraftMissingLetterRequestType {
  """A list of all of the banned hero ids in the draft."""
  bans: [Short]

  """A boolean representing if Radiant is first pick or not."""
  isRadiantFirstPick: Boolean!

  """
  The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported.
  """
  gameMode: Int!

  """A list of player request objects."""
  players: [PlusDraftMissingLetterPlayerObjectType]!

  """
  Due to Valve changing the way Picking has happened in the past, we require the
  GameVersionId so we know what version of the network to call.
  """
  gameVersionId: Short!
}

type PlusDraftPlayerHeroObjectType {
  heroId: Short
  pickValue: Decimal
  winValues: [Decimal]
  score: Float
  letter: PlusLetterType
}

input PlusDraftPlayerRequestType {
  """
  The steam id of the player. This will allow us to find player history on the player if he is not anonymous.
  """
  steamAccountId: Long

  """The slot of player. It is required to be in order from 0-9."""
  slot: Int!

  """
  When a player has selected a hero, this is the id. If a null is sent, we will send back a hero list of possible heroes.
  """
  heroId: Short

  """
  This is used when a player has not selected a hero, but wishes to play a hero.
  It will form the draft around the fact that when its his turn to pick, it will be that hero.
  """
  suggestHeroId: Short

  """
  The rank this played is.  In the event he is anonymous, use the lowest rank player in the game.
  """
  rank: Byte

  """
  The role this player will play. If a null is sent, we will assign the best possible role.
  """
  position: MatchPlayerPositionType

  """
  The role this player will play. If a null is sent, we will assign the best possible role.
  """
  order: Byte
}

type PlusDraftPlayerType {
  slot: Byte
  position: MatchPlayerPositionType
  positionValues: [Decimal]
  heroes: [PlusDraftPlayerHeroObjectType]
}

input PlusDraftRequestType {
  """
  The match Id or the lobby id of the match your sending.  This will cache data for the next calls to be quicker.
  """
  matchId: Long!

  """A list of all of the banned hero ids in the draft."""
  bans: [Short]

  """A boolean representing if Radiant is first pick or not."""
  isRadiantFirstPick: Boolean!

  """
  The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported.
  """
  gameMode: Int!

  """A list of player request objects."""
  players: [PlusDraftPlayerRequestType]!

  """
  Due to Valve changing the way Picking has happened in the past, we require the
  GameVersionId so we know what version of the network to call.
  """
  gameVersionId: Short!
}

type PlusDraftType {
  midOutcome: Decimal
  safeOutcome: Decimal
  offOutcome: Decimal
  winValues: [Decimal]
  durationValues: [Decimal]
  players: [PlusDraftPlayerType]
}

type PlusHeroTeamStatusAveragesType {
  cs: Decimal
  deaths: Decimal
  towerDamage: Decimal
  physicalDamage: Decimal
  magicalDamage: Decimal
  physicalDamageReceived: Decimal
  magicalDamageReceived: Decimal
  disableCount: Decimal
  disableDuration: Decimal
  stunCount: Decimal
  stunDuration: Decimal
  slowCount: Decimal
  slowDuration: Decimal
  healingAllies: Decimal
  purgeModifiers: Decimal
  weakenCount: Decimal
  weakenDuration: Decimal
  pureDamageReceived: Decimal
  pureDamage: Decimal
}

type PlusHeroTeamStatusDetailType {
  heroId: Int!
  basicBracket: RankBracketHeroTimeDetail
  position: MatchPlayerPositionType
  averages: PlusHeroTeamStatusAveragesType
}

type PlusHoverBanType {
  heroId: Short
  score: Decimal
  flags: Byte
}

type PlusHoverType {
  players: [PlusPlayerHoverType]
  bans: [PlusHoverBanType]
}

enum PlusLetterType {
  F
  D
  C
  B
  A
  S
}

type PlusPlayerHoverHeroType {
  heroId: Short
  winCount: Int!
  lossCount: Int!
}

type PlusPlayerHoverPlayerType {
  steamAccountId: Long
  matchCount: Int!
  winCount: Int!
  lastMatchDateTime: Long
}

input PlusPlayerHoverRequestType {
  """
  An array of steam account ids to limit the query to only return matches with
  these steam account ids. There is a maximum of 10 steam account ids allowed.
  """
  steamAccountIds: [Long]!

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """The amount of matches to have returned in your query. Max 1000"""
  take: Int

  """
  Should our Networks attempt to try to make Radiant Win the draft or Dire.
  """
  shouldRadiantWin: Boolean
}

type PlusPlayerHoverType {
  steamAccount: SteamAccountType
  matchCount: Int
  winCount: Int!
  coreCount: Int
  supportCount: Int
  imp: Int
  heroes: [PlusPlayerHoverHeroType]
  activity: Byte
  languageCode: [String]
  friends: [PlusPlayerHoverPlayerType]
  enemies: [PlusPlayerHoverPlayerType]
  lastMatchDateTime: Long
  heroesExperience: [Short]
  behaviorScore: Short
}

type PlusQuery {
  """
  The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given.
  """
  draft(
    """
    The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given.
    """
    request: PlusDraftRequestType!
  ): PlusDraftType

  """
  Gets a list of data of the players in the match, can send a max of 10 people. 
  If a user blocks their data on STRATZ, that data will not be returned.
  """
  playerMatchHistory(
    """The request object that will filter your PlusPlayerHover data."""
    request: PlusPlayerHoverRequestType!
  ): PlusHoverType

  """
  Returns back basic data about the user playing a specific hero.  Used in the Draft app to show post-pick data.
  """
  playerHeroHighlight(
    """
    The Steam Account Id to look up. If the person is anonymous, you will get a null.
    """
    steamAccountId: Long!

    """
    The hero id to include in this query, excluding all results that do not include this hero.
    """
    heroId: Short!
  ): PlayerDraftHeroHighlightType

  """
  Returns a set of events which contain each hero and their averages in each of
  the respected categories, sorted by rank bracket.
  """
  teamHeroStatus(
    """
    The id of the rank bracket to include in this query, excluding all results that do not include this rank bracket.
    """
    rankBracket: RankBracketHeroTimeDetail!
  ): [PlusHeroTeamStatusDetailType]

  """
  To save CPU cycles we limit the amount of heroes a person can play. If a
  player picks a hero outside the default list, we have no idea how good the
  hero would of been. You can call this endpoint to update the grade letter for
  that hero selection.
  """
  draftMissingLetter(request: PlusDraftMissingLetterRequestType!): PlusLetterType
}

type ProPlayerFollowType {
  steamAccountId: Long
  activity: Int
  matchCount: Int!
  coreCount: Int!
  supportCount: Int!
  steamAccount: SteamAccountType
}

type ProSteamAccountType {
  id: Long
  name: String
  realName: String
  fantasyRole: Byte
  teamId: Int
  sponsor: String
  isLocked: Boolean!
  isPro: Boolean!
  totalEarnings: Int!
  birthday: Long
  romanizedRealName: String
  roles: Byte
  aliases: [String]
  statuses: Byte
  twitterLink: String
  twitchLink: String
  instagramLink: String
  vkLink: String
  youTubeLink: String
  facebookLink: String
  weiboLink: String
  signatureHeroes: [String]
  position: MatchPlayerPositionType
  countries: [String]
  team: TeamType
}

type RabbitDetailType {
  lastUpdated: Long
  isOnline: Boolean!
  matchHistory: RabbitQueueDetailType
  matchDetail: RabbitQueueDetailType
  matchDetailDelay: RabbitQueueDetailType
  matchStats: RabbitQueueDetailType
  steamAccount: RabbitQueueDetailType
  matchLive: RabbitQueueDetailType
}

type RabbitQueueDetailType {
  queueCount: Int!
  queueInRate: Decimal
  queueOutRate: Decimal
}

enum RankBracket {
  UNCALIBRATED
  HERALD
  GUARDIAN
  CRUSADER
  ARCHON
  LEGEND
  ANCIENT
  DIVINE
  IMMORTAL
}

enum RankBracketHeroTimeDetail {
  UNCALIBRATED
  HERALD_GUARDIAN
  CRUSADER_ARCHON
  LEGEND_ANCIENT
  DIVINE_IMMORTAL
  FILTERED
  ALL
}

type RecentHighImpType {
  matchId: Long
  imp: Short
  match: MatchType
}

type RecentRampageType {
  matchId: Long
  heroId: Short
  hero: HeroType
  heroesKilled: [Short]
  match: MatchType
}

type RecentWinStreakType {
  matchId: Long
  winStreakCount: Int

  """The status of the win streak, Ended (0) or Ongoing (1)."""
  status: Int
  firstWonMatchDateTime: DateTime
  lastWonMatchDateTime: DateTime
  match: MatchType
}

type RegionType {
  id: Byte
  name: String
  clientName: String
  displayName: String
  leaderboardDivision: String
  langKey: String
  latitude: Decimal
  longitude: Decimal
  code: String
  matchGroup: Byte
  weekendTourneyDivision: String
}

type RoleType {
  roleId: Short
  name: String
  langKey: String
}

enum RuneAction {
  PICKUP
  BOTTLE
}

enum RuneEnums {
  HASTE
  REGEN
  DOUBLE_DAMAGE
  ILLUSION
  INVISIBILITY
  BOUNTY
  ARCANE
  WATER
}

enum Search {
  PLAYERS
  MATCHES
  LEAGUES
  TEAMS
  PRO_PLAYERS
  CASTERS
  GUILDS
}

type SearchType {
  players: [SteamAccountType]
  matches: [MatchType]
  leagues: [LeagueType]
  teams: [TeamType]
  proPlayers: [SteamAccountType]
  casters: [SteamAccountType]
  guild: GuildType
  direTideMatches: [DireTide2020CustomGameMatchType]
}

enum Series {
  BEST_OF_ONE
  BEST_OF_THREE
  BEST_OF_FIVE
  BEST_OF_TWO
}

type SeriesType {
  id: Long!
  type_: Series
  teamOneId: Int
  teamTwoId: Int
  leagueId: Int
  teamOneWinCount: Short
  teamTwoWinCount: Short
  winningTeamId: Int
  lastMatchDateTime: Long
  matches: [MatchType]
  teamOne: TeamType
  teamTwo: TeamType
  league: LeagueType
}

type ServerStatusType {
  isRedisOnline: Boolean!
  steamApiDetail: SteamApiDetailType
  rabbitDetail: RabbitDetailType
}

scalar Short

type SpiritBearInventoryObjectType {
  itemId: Short
}

type SpiritBearInventoryType {
  time: Int!
  item0: SpiritBearInventoryObjectType
  item1: SpiritBearInventoryObjectType
  item2: SpiritBearInventoryObjectType
  item3: SpiritBearInventoryObjectType
  item4: SpiritBearInventoryObjectType
  item5: SpiritBearInventoryObjectType
  backPack0: SpiritBearInventoryObjectType
  backPack1: SpiritBearInventoryObjectType
  backPack2: SpiritBearInventoryObjectType
  teleport0: SpiritBearInventoryObjectType
  neutral0: SpiritBearInventoryObjectType
}

type SteamAccountBattlePassType {
  steamId: Long
  eventId: Byte
  level: Int
}

type SteamAccountByRankType {
  rank: Byte
  playerCount: Int
}

type SteamAccountNameType {
  name: String
  lastSeenDateTime: Long
}

type SteamAccountSeasonActiveLeaderboardRankType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  avgImp: Short
  divisionId: LeaderboardDivision
  lastUpdateDateTime: Long
  matchCount: Short
  position: MatchPlayerPositionType
  positionValue: Byte
  rank: Short
  rankShift: Short
  topHeroOne: Short
  topHeroTwo: Short
  topHeroThree: Short
  winRate: Byte
}

type SteamAccountSeasonLeaderBoardRankType {
  steamAccountId: Long
  seasonRankId: Byte
  asOfDateTime: Long
  seasonLeaderBoardDivisionId: Byte
  rank: Short
}

type SteamAccountSeasonRankType {
  seasonRankId: Byte
  asOfDateTime: Long
  isCore: Boolean
  rank: Byte
}

type SteamAccountTeamMemberType {
  steamAccountId: Long
  steamAccount: SteamAccountType
  player: PlayerType
  teamId: Long
  firstMatchId: Long
  firstMatchDateTime: Long
  lastMatchId: Long
  lastMatchDateTime: Long
  team: TeamType
}

type SteamAccountType {
  id: Long
  profileUri: String!
  realName: String
  timeCreated: Long
  countryCode: String
  stateCode: String
  cityId: Int
  communityVisibleState: Int
  name: String
  lastLogOff: Long
  avatar: String
  primaryClanId: Long
  isDotaPlusSubscriber: Boolean
  isAnonymous: Boolean!
  isStratzAnonymous: Boolean!
  seasonRank: Byte
  seasonLeaderboardRank: Short
  seasonLeaderboardDivisionId: Byte
  proSteamAccount: ProSteamAccountType
  smurfFlag: Byte
  lastMatchDateTime: Long
  lastMatchRegionId: Byte
  battlepass: [SteamAccountBattlePassType]
}

type SteamApiDetailOutageType {
  secondsOffline: Int
  dateTime: Long
}

type SteamApiDetailType {
  isOnline: Boolean!
  outages: [SteamApiDetailOutageType]
}

enum StratzApiType {
  DATA_COLLECTOR
  MULTI_KEY
}

type StratzQuery {
  admin: AdminQuery
  user: UserQuery
  page: PageQuery

  """Returns a list of Stratz blogs."""
  blogs(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [BlogType]

  """Returns a list of News Items released by Dota 2 directly."""
  news: [NewsItemType]

  """
  Home page data that shows the total count of players and matches in our database.
  """
  ticker: [Int]

  """
  Shows the availability to major components required in the STRATZ foundation.
  """
  status: ServerStatusType

  """
  Returns a list of languages and an Id for reference. This is used throughout the site.
  """
  languages: [LanguageType]

  """Returns a list of Stratz blogs."""
  matchRetry(
    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    id: Long!
  ): Boolean
  search(request: FilterSearchRequestType): SearchType
}

enum Streak {
  MULTI_KILL
  KILL_STREAK
}

type StreakEventType {
  time: Int!
  heroId: Short
  type_: Streak
  value: Int!
}

enum TableCalculateEnum {
  AVERAGE
  MEDIAN
  HIGHEST
  LOWEST
}

input TeamMatchesRequestType {
  """
  The steam account id to include in this query, excluding all results that do not have this steam account id.
  """
  steamAccountId: Long

  """An array of Dota match ids to include in this query."""
  matchIds: [Long]

  """
  A league id to include in this query, excluding all results that do not have this league id.
  """
  leagueId: Int

  """
  A series id to include in this query, excluding all results that do not have this series id.
  """
  seriesId: Long

  """
  Whether STRATZ has yet parsed the data of the match or not, represented in a boolean.
  """
  isParsed: Boolean

  """
  The start DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  startDateTime: Long

  """
  The end DateTime of the Dota match(es) to include in this query, represented in unix seconds.
  """
  endDateTime: Long

  """
  An array of game mode ids to include in this query, excluding all results that do not include one of these game modes.
  """
  gameModeIds: [Byte]

  """
  An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types.
  """
  lobbyTypeIds: [Byte]

  """
  An array of game version ids to include in this query, excluding all results
  that do not include one of these game versions.
  """
  gameVersionIds: [Int]

  """
  An array of region ids to include in this query, excluding all results that do not include one of these regions.
  """
  regionIds: [Int]

  """
  An array of rank ids to include in this query, excluding all results that do
  not include one of these ranks. The value ranges from 0-80 with 0 being
  unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars.
  """
  rankIds: [Int]

  """
  STRATZ applys an formula to determine if a game is considered 'real'. We
  attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches
  that do not include any of these poor quality matches.
  """
  isStats: Boolean

  """
  An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
  """
  heroIds: [Short]

  """
  An array of lane ids (enum MatchLaneType) to include in this query, excluding
  all results that do not include one of these lanes. Roaming = 0, SafeLane = 1,
  Midlane = 2, Offlane = 3, Jungle = 4
  """
  laneIds: [Int]

  """
  An array of role ids (enum MatchPlayerRoleType) to include in this query,
  excluding all results that do not include one of these roles. Core = 0, Light
  Support = 1, Hard Support = 2
  """
  roleIds: [Int]

  """
  An array of award ids to include in this query, excluding all results that do
  not include one of these awards. The player award types include MVP (1), Top
  Core (2), and Top Support (3).
  """
  awardIds: [Int]

  """Include all matches that are party games, excluding all others."""
  isParty: Boolean

  """
  STRATZ gives 3 players in each game an award for playing well. MVP, Top Core,
  Top Support (enum MatchPlayerAwardType). If you include a query of
  'steamAccountId' then it will require that player to have gotten at least 1 of
  these awards for each match result.
  """
  hasAward: Boolean

  """
  An array of steam account ids found on your team to include in this query,
  excluding all results that do not include one of these steam accounts found on your team.
  """
  withFriendSteamAccountIds: [Long]

  """
  An array of hero ids found on your team to include in this query, excluding
  all results that do not include one of these heroes found on your team.
  """
  withFriendHeroIds: [Int]

  """
  The amount of matches to skip before collecting your query. Hint: Paging
  """
  skip: Int!

  """The amount of matches to have returned in your query. Max 1000"""
  take: Int!
}

type TeamPrizeType {
  leagueId: Int
  league: LeagueType
  teamId: Int
  team: TeamType
  standing: Int
  prizeAmount: Float
}

type TeamType {
  id: Int!
  name: String
  tag: String
  dateCreated: Long
  isPro: Boolean
  isLocked: Boolean
  countryCode: String
  url: String
  logo: String
  baseLogo: String
  bannerLogo: String
  winCount: Int
  lossCount: Int
  lastMatchDateTime: Long
  countryName: String
  coachSteamAccountId: Long
  coachSteamAccount: SteamAccountType

  """Find match details by leauge id."""
  matches(
    """
    The request object used to filter matches returned based on input criteria.
    """
    request: TeamMatchesRequestType!
  ): [MatchType]

  """Find match details by series id."""
  series(
    """
    The request object used to filter Series returned based on input criteria.
    """
    request: FilterSeriesRequestType!
  ): [SeriesType]

  """A List of all the players for a team."""
  members(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): [SteamAccountTeamMemberType]
}

type TI2020CustomGameDepthListAscensionAbilitiesObjectType {
  type_: TI2020CustomGameDepthListAscensionAbilitiesType
  abilityId: Short
  modifierId: Short
}

enum TI2020CustomGameDepthListAscensionAbilitiesType {
  ASCENSION_ARMOR
  ASCENSION_ARMOR_SAPPING
  ASCENSION_ATTACK_SPEED
  ASCENSION_BOMB
  ASCENSION_CHILLING_TOUCH
  ASCENSION_CRIT
  ASCENSION_DAMAGE
  ASCENSION_DRUNKEN
  ASCENSION_EXTRA_FAST
  ASCENSION_FLICKER
  ASCENSION_HEAL_SUPPRESSION
  ASCENSION_MAGIC_IMMUNITY
  ASCENSION_MAGIC_RESIST
  ASCENSION_VAMPIRIC
  ASCENSION_MAGNETIC_FIELD
  ASCENSION_SILENCE
  ASCENSION_FIREFLY
  ASCENSION_EMBIGGEN
  ASCENSION_VENGEANCE
  AGHSFORT_ASCENSION_INVIS
  ASCENSION_METEORIC
  ASCENSION_PLASMA_FIELD
  ASCENSION_BULWARK
}

enum TI2020CustomGameDepthListEncounterType {
  ENCOUNTER_EMPTY_CAVERN
  ENCOUNTER_EMPTY_BEACH
  ENCOUNTER_BREWMASTER
  ENCOUNTER_HELLBEARS_PORTAL_V_3
  ENCOUNTER_PINECONES
  ENCOUNTER_QUILL_BEASTS
  ENCOUNTER_JUNGLE_HIJINX
  ENCOUNTER_TUSK_SKELETONS
  ENCOUNTER_BOMBERS
  ENCOUNTER_DROW_RANGER_MINIBOSS
  ENCOUNTER_WAVE_BLASTERS
  ENCOUNTER_BABY_OGRES
  ENCOUNTER_MORPHLINGS_B
  ENCOUNTER_ZEALOT_SCARABS
  ENCOUNTER_OGRE_SEALS
  ENCOUNTER_WARLOCKS
  ENCOUNTER_GAUNTLET
  ENCOUNTER_MORTY_TRANSITION
  ENCOUNTER_PENGUINS_TRANSITION
  ENCOUNTER_MIRANA
  ENCOUNTER_MUSHROOM_MINES
  ENCOUNTER_LEGION_COMMANDER
  ENCOUNTER_TROLL_WARLORD
  ENCOUNTER_PUDGE_MINIBOSS
  ENCOUNTER_PUCKS
  ENCOUNTER_DARK_SEER
  ENCOUNTER_SPECTRES
  ENCOUNTER_SHADOW_DEMONS
  ENCOUNTER_NAGA_SIREN
  ENCOUNTER_DIRE_SIEGE
  ENCOUNTER_BIG_OGRES
  ENCOUNTER_DRAGON_KNIGHT
  ENCOUNTER_KUNKKA_TIDE
  ENCOUNTER_ALCHEMIST
  ENCOUNTER_ENRAGED_WILDWINGS
  ENCOUNTER_ELEMENTAL_TINY
  ENCOUNTER_BANDITS
  ENCOUNTER_BOMB_SQUAD
  ENCOUNTER_UNDEAD_WOODS
  ENCOUNTER_PHOENIX
  ENCOUNTER_BROODMOTHERS
  ENCOUNTER_FIRE_ROSHAN
  ENCOUNTER_BOSS_VISAGE
  ENCOUNTER_BOSS_TIMBERSAW
  ENCOUNTER_TEMPLE_GUARDIANS
  ENCOUNTER_STOREGGA
  ENCOUNTER_BOSS_VOID_SPIRIT
  ENCOUNTER_AGHANIM
  ENCOUNTER_JUNGLE_FIRE_MAZE
  ENCOUNTER_CLIFF_PASS
  ENCOUNTER_HELLFIRE_CANYON
  ENCOUNTER_TEMPLE_GARDEN
  ENCOUNTER_CASTLE_TRAPS
  ENCOUNTER_CRYPT_TRAPS
  ENCOUNTER_BONUS_CHICKEN
  ENCOUNTER_PANGOLIER
  ENCOUNTER_ROCK_GOLEMS
  ENCOUNTER_WENDIGOES
  ENCOUNTER_COLLAPSED_MINES
  ENCOUNTER_BEARS_LAIR
  ENCOUNTER_PINE_GROVE
  ENCOUNTER_SACRED_GROUNDS
  ENCOUNTER_DEEP_TRAPS
  ENCOUNTER_DARK_FOREST
  ENCOUNTER_TROPICAL_KEEP
  ENCOUNTER_SALTY_SHORE
  ENCOUNTER_REGAL_TRAPS
  ENCOUNTER_DESERT_OASIS
  ENCOUNTER_PRISON_TRAPS
  ENCOUNTER_BRIDGE_TRAPS
  ENCOUNTER_MOLE_CAVE
  ENCOUNTER_BLOB_DUNGEON
  ENCOUNTER_MULTIPLICITY
  ENCOUNTER_CATACOMBS
  ENCOUNTER_SWAMP_OF_SADNESS
  ENCOUNTER_CAVERN_TRAPS
  ENCOUNTER_AZIYOG_CAVERNS
  ENCOUNTER_BAMBOO_GARDEN
  ENCOUNTER_BOG_TRAPS
  ENCOUNTER_BOSS_WINTER_WYVERN
  ENCOUNTER_BOSS_EARTHSHAKER
  ENCOUNTER_BOSS_DARK_WILLOW
  ENCOUNTER_BOSS_RIZZRICK
  ENCOUNTER_PENGUIN_SLEDDING
  ENCOUNTER_BONUS_MANGO_ORCHARD
  ENCOUNTER_BONUS_HOOKING
  ENCOUNTER_MUSHROOM_MINES_2021
  ENCOUNTER_GAOLERS
  ENCOUNTER_EGGS_HOLDOUT
  ENCOUNTER_SPOOK_TOWN
  ENCOUNTER_TEMPLE_TRAPS
  ENCOUNTER_CANOPY_TRAPS
  ENCOUNTER_INNER_RING
  ENCOUNTER_LESHRAC
  ENCOUNTER_OUTWORLD
  ENCOUNTER_TWILIGHT_MAZE
  ENCOUNTER_RUINOUS_TRAPS
  ENCOUNTER_BEACH_TRAPS
  ENCOUNTER_GOLEM_GORGE
  ENCOUNTER_SNAPFIRE
  ENCOUNTER_POLARITY_SWAP
  ENCOUNTER_STONEHALL_CITADEL
  ENCOUNTER_MYSTICAL_TRAPS
  ENCOUNTER_HEDGE_TRAPS
  ENCOUNTER_TEMPLE_SIEGE
  ENCOUNTER_FORBIDDEN_PALACE
  ENCOUNTER_CRYPT_GATE
  ENCOUNTER_PUGNA_NETHER_REACHES
  ENCOUNTER_MINING_TRAPS
  ENCOUNTER_DUNGEON_TRAPS
  ENCOUNTER_BOSS_ARC_WARDEN
  ENCOUNTER_BOSS_CLOCKWERK_TINKER
  ENCOUNTER_BOSS_AMOEBA
  ENCOUNTER_BOSS_STOREGGA
  ENCOUNTER_BONUS_LIVESTOCK
  ENCOUNTER_BONUS_SMASH_CHICKENS
  ENCOUNTER_BONUS_GALLERY
  ENCOUNTER_TOXIC_TERRACE
  ENCOUNTER_HIDDEN_COLOSSEUM
  ENCOUNTER_FROZEN_RAVINE
  ENCOUNTER_PALACE_TRAPS
  ENCOUNTER_ICY_POOLS
  ENCOUNTER_DEMONIC_WOODS
  ENCOUNTER_THUNDER_MOUNTAIN
  ENCOUNTER_FRIGID_PINNACLE
  ENCOUNTER_VILLAGE_TRAPS
  ENCOUNTER_FORSAKEN_PIT
  ENCOUNTER_BURNING_MESA
  ENCOUNTER_SMASHY_AND_BASHY
  ENCOUNTER_PUSH_PULL
  ENCOUNTER_JUNGLE_TRAPS
  ENCOUNTER_TRANSITION_GATEWAY
  ENCOUNTER_PRIMAL_BEAST
  ENCOUNTER_EVENT_MINOR_SHARD_SHOP
  ENCOUNTER_EVENT_DOOM_LIFE_SWAP
  ENCOUNTER_EVENT_WARLOCK_LIBRARY
  ENCOUNTER_EVENT_ALCHEMIST_NEUTRAL_ITEMS
  ENCOUNTER_EVENT_BREWMASTER_BAR
  ENCOUNTER_EVENT_LIFE_SHOP
  ENCOUNTER_EVENT_MORPHLING_ATTRIBUTE_SHIFT
  ENCOUNTER_EVENT_TINKER_RANGE_RETROFIT
  ENCOUNTER_EVENT_NAGA_BOTTLE_RUNE
  ENCOUNTER_EVENT_SLARK
  ENCOUNTER_EVENT_ZEUS
  ENCOUNTER_EVENT_LESHRAC
  ENCOUNTER_EVENT_NECROPHOS
  ENCOUNTER_EVENT_SMALL_TINY_SHRINK
  ENCOUNTER_EVENT_BIG_TINY_GROW
  ENCOUNTER_EVENT_OGRE_MAGI_CASINO
  ENCOUNTER_SPLITSVILLE
  ENCOUNTER_AQUA_MANOR
  ENCOUNTER_JUNGLE_TREK
}

enum TI2020CustomGameDepthListRewardType {
  REWARD_TYPE_NONE
  REWARD_TYPE_GOLD
  REWARD_TYPE_EXTRA_LIVES
  REWARD_TYPE_TREASURE
}

type TI2020CustomGameHeroAbilityType {
  difficulty: TI2020CustomGameMatchDifficultyType
  heroId: Short
  customAbilityId: Short
  matchCount: Int
  winCount: Int
  pickCount: Int
}

type TI2020CustomGameHeroCompositionType {
  difficulty: TI2020CustomGameMatchDifficultyType
  heroId1: Short
  heroId2: Short
  heroId3: Short
  heroId4: Short
  matchCount: Int
  winCount: Int
  duration: Int
  wilsonScore: Decimal
}

type TI2020CustomGameHeroWinRateType {
  difficulty: TI2020CustomGameMatchDifficultyType
  heroId: Short
  matchCount: Int
  winCount: Int
}

type TI2020CustomGameMatchDepthListType {
  selectedElite: Boolean
  selectedEncounter: TI2020CustomGameDepthListEncounterType
  selectedEncounterType: Byte
  selectedHidden: Boolean
  selectedReward: TI2020CustomGameDepthListRewardType
  unselectedElite: Boolean
  unselectedEncounter: TI2020CustomGameDepthListEncounterType
  unselectedHidden: Boolean
  unselectedReward: TI2020CustomGameDepthListRewardType
  ascensionAbilities: [TI2020CustomGameDepthListAscensionAbilitiesObjectType]
}

enum TI2020CustomGameMatchDifficultyType {
  APPRENTICE
  MAGICIAN
  SORCERER
  GRANDMAGUS
  APEXMAGE
}

type TI2020CustomGameMatchType {
  id: Long
  didWin: Boolean
  durationSeconds: Short
  startDateTime: Long
  endDateTime: Long
  clusterId: Short
  lobbyType: Byte
  numKills: Short
  numDeaths: Short
  numHumanPlayers: Byte
  gameMode: Byte
  replaySalt: Long
  difficulty: TI2020CustomGameMatchDifficultyType
  depth: Byte
  seed: Int
  battlePoints: Short
  score: Int
  arcaneFragments: Short
  goldBags: Short
  regionId: Byte
  players(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long
  ): [TI2020CustomGamePlayerType]
  depthList: [TI2020CustomGameMatchDepthListType]
}

type TI2020CustomGamePlayerBlessingObjectType {
  type_: TI2020CustomGamePlayerBlessingType
  value: Short
}

enum TI2020CustomGamePlayerBlessingType {
  MODIFIER_BLESSING_AGILITY
  MODIFIER_BLESSING_ARMOR
  MODIFIER_BLESSING_ATTACK_SPEED
  MODIFIER_BLESSING_BASE
  MODIFIER_BLESSING_BOOK_AGILITY
  MODIFIER_BLESSING_BOOK_INTELLIGENCE
  MODIFIER_BLESSING_BOOK_STRENGTH
  MODIFIER_BLESSING_BOTTLE_UPGRADE
  MODIFIER_BLESSING_DAMAGE_BONUS
  MODIFIER_BLESSING_DAMAGE_REFLECT
  MODIFIER_BLESSING_DETONATION
  MODIFIER_BLESSING_EVASION
  MODIFIER_BLESSING_HEALTH_BOOST
  MODIFIER_BLESSING_INTELLIGENCE
  MODIFIER_BLESSING_LIFE_STEAL
  MODIFIER_BLESSING_MAGIC_DAMAGE_BONUS
  MODIFIER_BLESSING_MAGIC_RESIST
  MODIFIER_BLESSING_MANA_BOOST
  MODIFIER_BLESSING_MOVEMENT_SPEED
  MODIFIER_BLESSING_POTION_ARCANIST
  MODIFIER_BLESSING_POTION_DRAGON
  MODIFIER_BLESSING_POTION_ECHO_SLAM
  MODIFIER_BLESSING_POTION_HEALTH
  MODIFIER_BLESSING_POTION_MANA
  MODIFIER_BLESSING_POTION_PURIFICATION
  MODIFIER_BLESSING_POTION_RAVAGE
  MODIFIER_BLESSING_POTION_SHADOW_WAVE
  MODIFIER_BLESSING_POTION_TORRENT
  MODIFIER_BLESSING_REFRESHER_SHARD
  MODIFIER_BLESSING_RESPAWN_INVULNERABILITY
  MODIFIER_BLESSING_RESPAWN_TIME_REDUCTION
  MODIFIER_BLESSING_RESTORE_MANA
  MODIFIER_BLESSING_SPELL_LIFE_STEAL
  MODIFIER_BLESSING_STRENGTH
  BOTTLE_CHARGES
  STAT_AGI
  STAT_INT
  STAT_STR
  STAT_DAMAGE
  STAT_SPELL_AMP
  STAT_HEALTH
  STAT_MANA
  STAT_MAGIC_RESIST
  STARTING_GOLD
  PURIFICATION_POTION
  DEATH_DETONATION
  POTION_HEALTH
  POTION_MANA
  RESPAWN_TIME_REDUCTION
  BOTTLE_REGEN_DURATION
  BOTTLE_REGEN_MOVEMENT_SPEED
  ROSHAN_SHOP_DISCOUNT
  ORACLE_SHOP_DISCOUNT
  RESPAWN_INVULNERABILITY
  RESPAWN_HASTE
  RESPAWN_ATTACK_SPEED
  STAT_EVASION
  UPGRADE_REROLL
  ELITE_UPGRADE
  START_TOME
  BOSS_TOME
  EXTRA_LIFE
  MELEE_CLEAVE
  ATTACK_RANGE
  PROJECTILE_SPEED
  CAST_RANGE
  DAMAGE_ON_STUNNED
  REGEN_AROUND_ALLIES
  DEBUFF_DURATION_INCREASE
  LOW_HP_OUTGOING_DAMAGE
}

type TI2020CustomGamePlayerDepthListType {
  numDeaths: Short
  goldBags: Short
  kills: Short
  level: Byte
  networth: Int
  rarity: Byte
  selectedRewardAbilityId: Short
  selectedRewardAbility(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  unSelectedRewardAbilityId1: Short
  unSelectedRewardAbility1(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  unSelectedRewardAbilityId2: Short
  unSelectedRewardAbility2(
    """
    The language id to include in this query, excluding all results that do not have this language.
    """
    langaugeId: Int
  ): AbilityCustomGameType
  selectedRewardImageAbilityId: Short
}

type TI2020CustomGamePlayerType {
  matchId: Long
  playerSlot: Byte
  steamAccountId: Long
  steamAccount: SteamAccountType
  isVictory: Boolean!
  heroId: Short
  hero: HeroType
  deaths: Byte
  leaverStatus: Byte
  numLastHits: Short
  goldPerMinute: Short
  networth: Int
  experiencePerMinute: Short
  level: Byte
  goldSpent: Int
  partyId: Byte
  item0Id: Short
  item1Id: Short
  item2Id: Short
  item3Id: Short
  item4Id: Short
  item5Id: Short

  """
  The item id of the dedicated neutral item slot (7.24 and after). From game
  versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id).
  """
  neutral0Id: Short
  arcaneFragments: Short
  bonusArcaneFragments: Short
  goldBags: Short
  neutralItemId: Short
  depthList: [TI2020CustomGamePlayerDepthListType]
  blessings: [TI2020CustomGamePlayerBlessingObjectType]
}

type TI2020CustomGameRoomModifierType {
  difficulty: TI2020CustomGameMatchDifficultyType
  modifierId: Short
  matchCount: Int
  winCount: Int
  deathCount: Int
  eliteMatchCount: Int
  eliteWinCount: Int
  eliteDeathCount: Int
}

type TI2020CustomGameRoomType {
  difficulty: TI2020CustomGameMatchDifficultyType
  encounterId: TI2020CustomGameDepthListEncounterType
  matchCount: Int
  winCount: Int
  pickCount: Int
  deathCount: Int
  eliteMatchCount: Int
  eliteWinCount: Int
  elitePickCount: Int
  eliteDeathCount: Int
}

type TopPlayersByHeroType {
  heroId: Short
  players: [PlayerLeaderBoardByHeroType]
}

type TotalMatchCountType {
  matchCount: Long
}

type TotalPlayerCountType {
  playerCount: Long
}

type TowerDamageDetailType {
  time: Int!
  attacker: Short
  npcId: Short
  damage: Int!
  byAbility: Short
  byItem: Short
}

type TwitchTrackerPlayerHeroType {
  heroId: Int!
  matchCount: Int!
  winCount: Int!
}

type TwitchTrackerPlayerMatchType {
  matchId: Long
  heroId: Int!
  lane: MatchLaneType
  role: MatchPlayerRoleType
  position: MatchPlayerPositionType
  killCount: Short
  deathCount: Short
  assistCount: Short
  endDateTime: Long
  isVictory: Boolean!
  award: MatchPlayerAward
}

type TwitchTrackerPlayerType {
  steamAccountId: Long
  activity: PlayerBehaviorActivity
  name: String
  avatar: String
  rank: Int
  leaderboardRank: Int
  proPlayerName: String
  matchCountLast100: Int!
  winCountLast100: Int!
  uniqueHeroLast100: Int!
  coreCountLast100: Int!
  topHeroLast100: [TwitchTrackerPlayerHeroType]
  matches: [TwitchTrackerPlayerMatchType]
}

input UpdateFollowerRequestType {
  feedLevel: Byte
  emailLevel: Byte
  dailyEmail: Boolean
  weeklyEmail: Boolean
  monthlyEmail: Boolean
  overrideAllUsers: Boolean!
}

input UpdateMatchReplayMatchUploadPlayerObjectType {
  steamAccountId: Long!
  position: MatchPlayerPositionType
}

input UpdateMatchReplayUploadObjectType {
  matchReplayUploadTeamId: Int!
  matchId: Long
  leagueId: Int
  radiantTeamId: Int
  direTeamId: Int
  isActive: Boolean
  notes: String
  players: [UpdateMatchReplayMatchUploadPlayerObjectType]
}

type UserHomepageType {
  """A list of blog components to be displayed separately on the homepage."""
  blogs(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of blog ids to exclude in this query, including all results that do not include one of these blogs.
    """
    excludedBlogIds: [Int]
  ): [BlogType]
  upcomingLeagues(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results
    that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueType]
  inProgressLeagues(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results
    that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueType]
  leagueMetas(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of league ids to exclude in this query, including all results that do not include one of these leagues.
    """
    excludedLeagueIds: [Int]

    """
    An array of league ids to include in this query, excluding all results that do not include one of these leagues.
    """
    includedLeagueIds: [Int]

    """
    An array of league tier ids to include in this query, excluding all results
    that do not include one of these league tiers.
    """
    includedLeagueTierIds: [Int]
  ): [LeagueMetaType]
  topProPlayers(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [ProPlayerFollowType]
  topPlayersByHeroType(
    """The amount to have returned in your query."""
    heroComponentsTake: Int

    """The amount to have returned in your query."""
    playersTake: Int

    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]

    """
    An array of rank bracket ids to include in this query, excluding all results
    that do not include one of these rank brackets.
    """
    rankBracketIds: [Byte]
  ): [TopPlayersByHeroType]
  topSynergiesByHero(
    """The amount to have returned in your query."""
    synergyComponentsTake: Int

    """
    An array of hero ids to include in this query, excluding all results that do not include one of these heroes.
    """
    heroIds: [Short]
  ): [HomepageHeroSynergyType]
  matchAwards(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """
    An array of award ids to include in this query, excluding all results that
    do not include one of these awards. The player award types include MVP (1),
    Top Core (2), and Top Support (3).
    """
    matchPlayerAwardTypeIds: [Byte]
  ): [MatchType]
  recentRampages(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [RecentRampageType]
  recentWinStreaks(
    """
    This value is hard-coded to 1 if passed in, due to the way win streaks are currently stored.
    """
    take: Int
  ): [RecentWinStreakType]
  recentHighImps(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [RecentHighImpType]
  recentMatches(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [MatchPlayerType]
  activeLeagueGames(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [MatchLiveType]
  topLiveGames(
    """The amount to have returned in your query."""
    take: Int

    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int
  ): [MatchLiveType]
  totalComponents: Int
}

type UserQuery {
  """Find user details of the currently logged in user."""
  profile: UserType

  """Returns a list of Stratz blogs."""
  homepage(
    """The amount to have returned in your query."""
    take: Int!
  ): UserHomepageType

  """Gets the list of followers the person is following."""
  followers: [FollowerType]

  """Gets the list of followers the person is following."""
  following: [FollowerType]

  """Gets a list of completed tutorials from the logged in user."""
  completedTutorials: [Short]

  """Returns a list of feed events for the logged in user."""
  feed(
    """The amount to skip before collecting your query. Hint: Paging"""
    skip: Int

    """The amount to have returned in your query."""
    take: Int
  ): FeedResponseType
}

type UserType {
  profile: CaptainJackIdentityPrivateProfileType
  steamAccount: SteamAccountType
  recentMatch: MatchType
  followingCount: Int
  followerCount: Int
  followingLeagueCount: Int
  followingTeamCount: Int
  stratzApiApplications: [CaptainJackIdentityApiApplicationType]
}

scalar UShort

type VendorQuery {
  dotaNext: DotaNextQuery

  """Used by the Dota 2 Twitch Tracker for Dota Stats"""
  twitchTracker(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!
  ): TwitchTrackerPlayerType
}

enum XpReason {
  OTHER
  HEROES
  CREEPS
  ROSHAN
  TOME_OF_KNOWLEDGE
  OUTPOSTS
}

type YogurtMutation {
  """
  Create a new match replay upload team. teamName, emailAddress, and teamId are required input fields.
  """
  createTeam(
    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamName: String!

    """
    The desired email address of the match replay upload team. Cannot be blank or whitespace.
    """
    emailAddress: String!

    """
    The desired dota team id of the match replay upload team. Must be a real team created in the dota client.
    """
    teamId: Int!
  ): MatchReplayUploadTeamType

  """
  Update a new match replay upload team. matchReplayUploadTeamId is a required input field.
  """
  updateTeam(
    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamId: Int!

    """
    The desired team name of the match replay upload team. Cannot be blank or whitespace.
    """
    matchReplayUploadTeamName: String

    """
    The desired dota team id of the match replay upload team. Must be a real team created in the dota client.
    """
    teamId: Int
  ): Boolean

  """
  Add a member to a match replay upload team. steamAccountId and matchReplayUploadTeamId are required input fields.
  """
  addTeamMember(
    """
    The steam account id to include in this query, excluding all results that do not have this steam account id.
    """
    steamAccountId: Long!

    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!
  ): Boolean

  """
  Update a member of a match replay upload team. memberCaptainJackIdentityId,
  matchReplayUploadTeamId, and isAdmin are required input fields.
  """
  updateTeamMember(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    Whether the match replay upload team member you wish to update is an admin of that team.
    """
    isAdmin: Boolean!
  ): Boolean

  """
  Set the default team of a match replay upload team member.
  memberCaptainJackIdentityId and matchReplayUploadTeamId are required input fields.
  """
  setTeamMemberDefaultTeam(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!
  ): Boolean

  """
  Remove a member of a match replay upload team. memberCaptainJackIdentityId and
  matchReplayUploadTeamId are required input fields.
  """
  removeTeamMember(
    """
    The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id.
    """
    captainJackIdentityId: ID!

    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!
  ): Boolean

  """
  Update the data of a match replay upload. updateMatchReplayUploadObject is a required input field.
  """
  update(
    """
    This object contains all of the fields a user is allowed to update on a
    match replay upload. Null fields are not updated. Fields set to 0 are
    updated to null in the database.
    """
    updateMatchReplayUploadObject: UpdateMatchReplayUploadObjectType!
  ): Boolean

  """
  Validate the data of a match replay upload, adding the match replay upload to
  the queryable data set associated with the match replay upload team.
  matchReplayUploadTeamId and matchId are required input fields.
  """
  validate(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Invalidate the data of a match replay upload, removing the match replay upload
  from the queryable data set associated with the match replay upload team.
  matchReplayUploadTeamId and matchId are required input fields.
  """
  invalidate(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Delete the data of a match replay upload, removing the match replay upload
  from the queryable data set associated with the match replay upload team.
  matchReplayUploadTeamId and matchId are required input fields.
  """
  delete(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  Delete the data of a match replay upload, removing the match replay upload
  from the queryable data set associated with the match replay upload team.
  matchReplayUploadTeamId and matchId are required input fields.
  """
  linkSeriesId(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """An array of Dota match ids to include in this query."""
    matchIds: [Long]!
  ): Boolean

  """
  Remove the series id for all of the input matches. matchReplayUploadTeamId and matchIds are required input fields.
  """
  removeSeriesId(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """An array of Dota match ids to include in this query."""
    matchIds: [Long]!
  ): Boolean

  """
  Import a public match as a match replay upload to the match replay upload
  team's data set. matchReplayUploadTeamId and matchId are required input fields.
  """
  importMatch(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
  ): Boolean

  """
  If the Picks and Bans for a match are missing or invalid, this allows you to update them.
  """
  importPickBans(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The id of the Dota match to include in this query, excluding all results that do not include this id.
    """
    matchId: Long!
    pickBans: [ImportPickBanType]!
  ): Boolean
}

type YogurtQuery {
  """
  Find a match replay upload team by match replay upload team id. matchReplayUploadTeamId is a required input field.
  """
  team(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!
  ): MatchReplayUploadTeamType

  """
  Find all match replay upload teams associated with the currently logged in user.
  """
  teams: [MatchReplayUploadTeamType]

  """
  Find the defualt match replay upload team associated with the currently logged in user.
  """
  defaultTeam: MatchReplayUploadTeamType

  """
  Find match replay upload team members by match replay upload team id. matchReplayUploadTeamId is a required input field.
  """
  teamMembers(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!
  ): [MatchReplayUploadTeamMemberType]

  """
  Find match replay uploads by match replay upload team id. matchReplayUploadTeamId and request are required input fields.
  """
  overview(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The request object filtering which match replay uploads to include in this
    query, excluding all results that do not pass through this filter.
    """
    request: FilterMatchReplayUploadRequestType
  ): MatchReplayUploadOverviewType

  """
  Find the list of Hero's in the game and determine basic output by grouping them together.
  """
  heroSummary(
    """
    The id of the match replay upload team to include in this query, excluding
    all results that do not include this match replay upload team id.
    """
    matchReplayUploadTeamId: Int!

    """
    The request object filtering which match replay uploads to include in this
    query, excluding all results that do not pass through this filter.
    """
    request: FilterMatchReplayUploadRequestType
  ): [MatchReplayUploadHeroSummaryType]
}

