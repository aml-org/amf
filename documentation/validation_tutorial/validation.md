# Validation Tutorial

This tutorial will review the custom validation mechanism included in the AMF parser that makes it
possible to define, group, document, reuse and execute common validation rules over RAML, OAS and
AsyncAPI specifications.

You can think of custom validations as a version of validation languages like XML Schema or JSON Schema but capable of
constraining the graph of metadata generated by AMF when parsing any of the supported specifications.

The validation mechanism relies on [W3C SHACL](https://www.w3.org/TR/shacl/) to validate the graph of information generated by the 
AMF parser.No knowledge of SHACL is required to follow this tutorial, only basic knowledge of [W3C JSON-LD](https://www.w3.org/TR/json-ld/), 
the format used by AMF to encode the parsed graph of information from the input API spec, is expected. 

[JSON-LD Playground](https://json-ld.org/)
can be used to learn the basics about JSON-LD required by this tutorial.


## 1. Writing and executing a custom validation

The custom validation mechanism relies on defining set of validation rules known as **"Validation Profiles"**.

A validation profiles defines the name of the profile, documentation, a set of rules and the severity
levels associated to each rule.

Profiles are encoded into YAML documents.
The next example shows a very simple validation profile:


File: *$AMF_ROOT/documentation/validation_tutorial/examples/example1/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test1

violation:
  - version-format

validations:

  version-format:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      core.version:
        pattern: ^v[0-9]+\.[0-9]+\.[0-9]+$
```

This profile defines a new profile `Test1` with a single validation rule called `version-format`.
The validation constrains the version of the API model being parsed with a regular expression defining
the format of the version string.

Definition of the validation involves the following parts:

- `targetClass`: Defines the class of node in the parsed graph that is the target of the validation. This means that all 
nodes in the graph with that class (`apiContract.WebAPI`) in this case will be checked for the all the validation 
 rules defined in the validation

- `propertyConstraints`: Defines validation constraints for properties in the target node. In this case we are targeting
the `core.version` property and setting a `pattern` constraint

Additionally the profile is setting a `violation` severity for this validation rule using the `violation` entry in the
document.

Let's try to validate an example API:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example1/api.raml*
```yaml
#%RAML 1.0

title: Example API
version: 1.0
``` 

When can parse this RAML file with the following command line: 

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" documentation/validation_tutorial/examples/example1/api.raml | jq .
```

AMF generates the following output JSON-LD graph:

```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Example API"
          }
        ],
        "core:version": [
          {
            "@value": "1.0"
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example1/api.raml",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
```

Here we can see how the node with id (`@id`) `#/web-api` 
has associated the target class `apiContract:WebAPI`.
We can also see how the constrained property `core:version` is present and has the value `1.0`.

We can now parse the API but passing our custom profile as the validation to be applied and enforced (using the `-cp` flag):

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar validate -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example1/profile.yaml documentation/validation_tutorial/examples/example1/api.raml
```

AMF will return the following error text describing the validation, the node violating the constraint, the property
holding the invalid data and some lexical information about the location of the value in the input file;

```text
Model: file://documentation/validation_tutorial/examples/example1/api.raml
Profile: Test1
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#version-format
  Message: Unsatisfied constraint version-format
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example1/api.raml#/web-api
  Property: http://a.ml/vocabularies/core#version
  Position: Some(LexicalInformation([(4,9)-(4,12)]))
  Location: file://documentation/validation_tutorial/examples/example1/api.raml
```

The report can be obtained as machine processable JSON-LD version using the `validate` instead of the `parse` command:

 ```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example1/profile.yaml documentation/validation_tutorial/examples/example1/api.raml
```

That will return the following JSON-LD document containing a standard [SHACL validation report](https://www.w3.org/TR/shacl/#validation-report):

```json
{
  "@type": "http://www.w3.org/ns/shacl#ValidationReport",
  "http://www.w3.org/ns/shacl#conforms": false,
  "http://www.w3.org/ns/shacl#result": [
    {
      "@type": "http://www.w3.org/ns/shacl#ValidationResult",
      "http://www.w3.org/ns/shacl#resultSeverity": {
        "@id": "http://www.w3.org/ns/shacl#Violation"
      },
      "http://www.w3.org/ns/shacl#focusNode": {
        "@id": "file://documentation/validation_tutorial/examples/example1/api.raml#/web-api"
      },
      "http://www.w3.org/ns/shacl#resultPath": {
        "@id": "http://a.ml/vocabularies/core#version"
      },
      "http://www.w3.org/ns/shacl#resultMessage": "Unsatisfied constraint version-format",
      "http://www.w3.org/ns/shacl#sourceShape": {
        "@id": "http://a.ml/vocabularies/data#version-format"
      },
      "http://a.ml/vocabularies/amf/parser#lexicalPosition": {
        "@type": "http://a.ml/vocabularies/amf/parser#Position",
        "http://a.ml/vocabularies/amf/parser#start": {
          "@type": "http://a.ml/vocabularies/amf/parser#Location",
          "http://a.ml/vocabularies/amf/parser#line": 4,
          "http://a.ml/vocabularies/amf/parser#column": 9
        },
        "http://a.ml/vocabularies/amf/parser#end": {
          "@type": "http://a.ml/vocabularies/amf/parser#Location",
          "http://a.ml/vocabularies/amf/parser#line": 4,
          "http://a.ml/vocabularies/amf/parser#column": 12
        }
      }
    }
  ]
}
```

Great! we have validated our first API spec with a custom validation profile.

If we replace the version of the API spec by a compliant version according to the defined constraint, the validation error
should disappear from the report.

Notice that the same validation profile can also be applied to an OAS or AsyncAPI specifications.
For example, if we write this equivalente OAS spec:

File: *documentation/validation_tutorial/examples/example1/api.json*
```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Example API",
    "version": "1.0"
  },
  "paths": {}
}
```

If we parse it from the command line:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 3.0" -mime-in "application/json" -cp file://documentation/validation_tutorial/examples/example1/profile.yaml documentation/validation_tutorial/examples/example1/api.json
```

We should get an equivalent validation error:

```text
Model: file://documentation/validation_tutorial/examples/example1/api.json
Profile: Test1
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#version-format
  Message: Unsatisfied constraint version-format
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example1/api.json#/web-api
  Property: http://a.ml/vocabularies/core#version
  Position: Some(LexicalInformation([(5,15)-(5,20)]))
  Location: file://documentation/validation_tutorial/examples/example1/api.json
```

In the examples of this document we will use the regular text report instead of the equivalent JSON-LD encoded SHACL report.

The rest of this tutorial will expand this basic flow explaining how more sophisticated and advanced validation profiles
can be written.

## 2. Basic scalar validations

The simpler way of writing validation rules is using simple property constraints through the `propertyConstraints` facet 
in the validation profile document.

There is a number of property constraints over scalar properties that can be defined:

- `pattern`: Validates the value of a property in a target node against the provided regular expression
- `maxCount`: Validates the maximum number of values that the target node can have for a property
- `minCount`: Validates the minimum number of values that the target node can have for a property
- `minExclusive`: Validates the minimum value that a value in a property of the target node can have
- `maxExclusive`: Validates the maximum value that a value in a property of the target node can have
- `minInclusive`:Validates the minimum or equal value that a value in a property of the target node can have
- `maxInclusive`: Validates the maximum or equal value that a value in a property of the target node can have
- `datatype`: Validates the type of scalar value (integer, string, float, etc.) a value for a property of the target node must have
- `in`: Validates that the value for a property in a target node matches one of the values provided as an array in the validation rule

All these validations must be associated to a particular property under the `propertyConstraints` property in a validation
profile rule. The key of the `propertyConstraints` node must be a namespaced version of the property URI.

You can find the name of the properties in the JSON-LD output generated by the parser as a URI or CURIE, or you can check
the standard description of the [API model](https://github.com/aml-org/amf/blob/develop/vocabularies/dialects/canonical_webapi_spec.yaml) 
generated by AMF as a YAML file to find the properties that can be potentially constrained.

Let's unpack each of these validations.

### 2.1 Pattern

We already explained the way pattern works. It allows you to defined a regular expression that will constraint any property
in any node holding a string value. If the property has multiple values, all of them will be validated.

For example, the following profile will constraint the possible values for the protocols associated to the API using a 
regular expression over the `apiContract.scheme` property of the `apiContract.WebAPI` node class:

File: `$AMF_ROOT/documentation/validation_tutorial/examples/example2/profile.yaml`
```yaml
#%Validation Profile 1.0

profile: Test2

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        pattern: ^http|https$
```

Let's take a look at the following OAS 2.0 API spec that defines `ws` as valid for the protocols:

File: `$AMF_ROOT/documentation/validation_tutorial/examples/example2/api.json`
```json
{
  "swagger": "2.0",
  "info": {
    "title": "Basic servers",
    "version": "1.0"
  },
  "schemes": [
    "https",
    "ws"
  ],
  "paths": {}
}
```

If we look at the JSON-LD graph generated by the parser, we can find two values `http` and `ws` for the `apiContract.schemes`
property:

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "OAS 2.0" -mime-in "application/json" documentation/validation_tutorial/examples/example2/api.json | jq .
```

```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Basic servers"
          }
        ],
        "apiContract:scheme": [
          {
            "@value": "https"
          },
          {
            "@value": "ws"
          }
        ],
        "core:version": [
          {
            "@value": "1.0"
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example2/api.json",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
```


If now we try to validate using the profile we have just defined we will obtain a validation constraint pointing at the
`ws` protocol: 

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 2.0" -mime-in "application/json" -cp file://documentation/validation_tutorial/examples/example2/profile.yaml documentation/validation_tutorial/examples/example2/api.json | jq .
```

```text
Model: file://documentation/validation_tutorial/examples/example2/api.json
Profile: Test2
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#allowed-protocols
  Message: Unsatisfied constraint allowed-protocols
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example2/api.json#/web-api
  Property: http://a.ml/vocabularies/apiContract#scheme
  Position: Some(LexicalInformation([(7,2)-(10,3)]))
  Location: file://documentation/validation_tutorial/examples/example2/api.json
```

Notice how in this case the `pattern` validation constraint has been applied to both values of the `apiContract.scheme`
property.

### 2.2 minCount and maxCount

Validation constraints `minCount` and `maxCount` can be used to limit how many values a property in any target node can have.

`minCount` is specially interesting since it can be used to make part of the spec optional, if set with a `minCount` value
of zero or mandatory if `minCount` has a value major than zero.

For example, the following profile makes it mandatory to provide the name of an operation, parsed as a node of class 
`apiContract.Operation` through the `core.name` property:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example3/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test3a

violation:
  - mandatory-operation-name

validations:

  mandatory-operation-name:
    targetClass: apiContract.Operation
    propertyConstraints:
      core.name:
        minCount: 1
```

In OAS 3.0 names for operations are provided through the `operationId` property, so the following API should trigger a
validation error:

```yaml
openapi: 3.0.0

info:
  title: Example API

paths:
  /test:
    get:
      summary: test path
```

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 3.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example3/profile.yaml documentation/validation_tutorial/examples/example3/api.yaml
```

```text
Model: file://documentation/validation_tutorial/examples/example3/api.yaml
Profile: Test3a
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#mandatory-operation-name
  Message: Unsatisfied constraint mandatory-operation-name
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example3/api.yaml#/web-api/end-points/%2Ftest/get
  Property: http://a.ml/vocabularies/core#name
  Position: Some(LexicalInformation([(8,4)-(9,24)]))
  Location: file://documentation/validation_tutorial/examples/example3/api.yaml
```

if we provide the `operationId` value for the `get` operation in the `/test` endpoint, the validation will disappear.

`maxCount` can be used to limit the maximum number of values a property can have in the parsed graph.

For example we could modify the profile discussed in section 2.1 to limit not only the value of the protocol shcemes but
also the number of protocols that can defined o a single one:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example3/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test2 Modified

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        pattern: ^http|https$
        maxCount: 1
```

Now validating the previous OAS 2.0 spec defined in section 2.1 should produce two errors, one about the value of the
schemes and another one about the maximum number of schemes defined:

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 2.0" -mime-in "application/json" -cp file://documentation/validation_tutorial/examples/example3/profile2.yaml documentation/validation_tutorial/examples/example2/api.json
```

```text
Model: file://documentation/validation_tutorial/examples/example2/api.json
Profile: Test2 Modified
Conforms? false
Number of results: 2

Level: Violation

- Source: http://a.ml/vocabularies/data#allowed-protocols
  Message: Unsatisfied constraint allowed-protocols
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example2/api.json#/web-api
  Property: http://a.ml/vocabularies/apiContract#scheme
  Position: Some(LexicalInformation([(7,2)-(10,3)]))
  Location: file://documentation/validation_tutorial/examples/example2/api.json

- Source: http://a.ml/vocabularies/data#allowed-protocols
  Message: Unsatisfied constraint allowed-protocols
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example2/api.json#/web-api
  Property: http://a.ml/vocabularies/apiContract#scheme
  Position: Some(LexicalInformation([(7,2)-(10,3)]))
  Location: file://documentation/validation_tutorial/examples/example2/api.json
```

### 2.3 minExclusive, maxExclusive, minInclusive, maxInclusive

This set of constraints makes it possible to control the ranges of numeric values in the parsed graph.

For example, the following profile uses these constraints to limit the range of values that are valid for the elements
 a defined for a RAML Array type:
 
 File: *$AMF_ROOT/documentation/validation_tutorial/examples/example4/profile.yaml*
 ```yaml
#%Validation Profile 1.0

profile: Test4

violation:
  - array-limits

validations:

  array-limits:
    targetClass: raml-shapes.ArrayShape
    propertyConstraints:
      shacl.minCount:
        minInclusive: 25
        maxExclusive: 50
 ```

In this `array-limits` validaion rule, targetting all RAML arrays, parsed as `raml-shapes.ArrayShape` nodes, we have setup
two constraints `minInclusive` and `maxExclusive` constraining the possible values for the elements in the array, parsed
by AMF as `shacl.minCount` properties in the output graph.
The values are constrained betweeen the values 25 (included) and 50.

Provided a simple API defining some array types:

```yaml
#%RAML 1.0

title: Example API
version: 1.0

types:
  Emails:
    type: any[]
    minItems: 100
```

If we try to parse it using the previous validation profile we should obtain a validation error, since the `minITems` for
the defined array (100) does not fall between the [25,50) range.

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example4/profile.yaml documentation/validation_tutorial/examples/example4/api.raml
```

```text
Model: file://documentation/validation_tutorial/examples/example4/api.raml
Profile: Test4
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#array-limits
  Message: Unsatisfied constraint array-limits
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example4/api.raml#/declarations/types/array/Emails
  Property: http://www.w3.org/ns/shacl#minCount
  Position: Some(LexicalInformation([(9,14)-(9,17)]))
  Location: file://documentation/validation_tutorial/examples/example4/api.raml
```

### 2.4 datatype

`datatype` is a constraint that limits the valid scalar value for a property in the parsed graph. This constraint is not
specially useful in custom validations, since RAML, OAS and AsyncAPI have well defined types for all the properties, but
it can still used to modify standard type definitions, for example, making it mandatory for a version to be an integer, 
instead of a sting. They are also used internally to define the standard validations for the different API specs.

We will got back to this constraint when reviewing how override default validations, changing the default validation profiles
associated to the different standards.


### 2.5 in

`in` makes it possible to specify an enumeration of values that constraint the possible values for a certain property in
a node. Values can be booleans, numeric values or strings.

The following example rewrites the profile used as an example in section 2.1 to use a `in` constraint instead of `pattern`
to constrain the possible values for the `schemes` defined by default in an API spec:

```yaml
#%Validation Profile 1.0

profile: Test5

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        in: [ http, https ]
``` 

If we try to validate the same OAS 2 API defined in section 2.1 with this profile we wil obtain an equivalent violation:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 2.0" -mime-in "application/json" -cp file://documentation/validation_tutorial/examples/example5/profile.yaml documentation/validation_tutorial/examples/example2/api.json
```

```text
Model: file://documentation/validation_tutorial/examples/example2/api.json
Profile: Test5
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#allowed-protocols
  Message: Unsatisfied constraint allowed-protocols
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example2/api.json#/web-api
  Property: http://a.ml/vocabularies/apiContract#scheme
  Position: Some(LexicalInformation([(7,2)-(10,3)]))
  Location: file://documentation/validation_tutorial/examples/example2/api.json
```

## 3. Property pairs validations

Validation constraints discussed in section 2 are all validations over a single scalar property. In this section we will
review validations constraining pairs of scalar properties:

- *lessThanProperty*: establishes a less than constraint over the values of two scalar properties in a noe
- *lessThanOrEqualsToProperty*: establishes a more than constraint over the values of two scalar properties in a noe
- *equalsToProperty*: establishes an equality constraint over tha values of two scalar properties in a node
- *disjointWithProperty*: establishes an inequality constraint over the values of two scalar properties in a node

The rest of this section will review and provide examples of these constraints.

### 3.1 lessThanProperty, lessThanOrEqualsToProperty

`lessThanProperty` and `lessThanOrEqualsToProperty` makes it possible to define that the values in one property of a node
must be less than or less than or equal to the values in another property of the same node.

The following OAS 3.0.0 API spec defines maximum and minimum length for a string schema called `name`:

File: `$AMF_ROOT/documentation/validation_tutorial/examples/example6/api.yaml`
```yaml
openapi: 3.0.0

info:
  title: Example API

components:
  schemas:
    name:
      type: string
      minLength: 500
      maxLength: 100

paths: {}
```

Here we can see how there is an error over those limits, making `minLength` greater than the `maxLength`.

If we parse the specification, we can see how both JSON Schema constraints are stored in the parsed graph using the 
`sh:minLength` and `sh:maxLength` properties of a `raml-shapes:ScalarShape` node:

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "OAS 3.0" -mime-in "application/yaml" documentation/validation_tutorial/examples/example6/api.yaml | jq .
```

```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Example API"
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "doc:declares": [
      {
        "@id": "#/declarations/types/scalar/name",
        "@type": [
          "raml-shapes:ScalarShape",
          "raml-shapes:AnyShape",
          "shacl:Shape",
          "raml-shapes:Shape",
          "doc:DomainElement"
        ],
        "shacl:datatype": [
          {
            "@id": "http://www.w3.org/2001/XMLSchema#string"
          }
        ],
        "shacl:minLength": [
          {
            "@value": 500
          }
        ],
        "shacl:maxLength": [
          {
            "@value": 100
          }
        ],
        "shacl:name": [
          {
            "@value": "name"
          }
        ]
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example6/api.yaml",
      "shacl": "http://www.w3.org/ns/shacl#",
      "raml-shapes": "http://a.ml/vocabularies/shapes#",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
```

We could write a validation profile to capture these kind of errors:

```yaml
#%Validation Profile 1.0

profile: Test6

violation:
  - test-min-length

validations:
  test-min-length:
    targetClass: raml-shapes.ScalarShape
    message: Min length must be less than max length must match in scalar
    propertyConstraints:
      shacl.minLength:
       lessThanProperty: shacl.maxLength
```

Notice how the value fot the `lessThanProperty` is another property that is the target of the comparison, in this case `shacl.maxLength`.

If we try to parse again the API spec but using the profile, a validation about the `minLength` / `maxLength` constraints.

```yaml
$ java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 3.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example6/profile.yaml documentation/validation_tutorial/examples/example6/api.yaml
```

```text
Model: file://documentation/validation_tutorial/examples/example6/api.yaml
Profile: Test6
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#test-min-length
  Message: Min length must be less than max length must match in scalar
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example6/api.yaml#/declarations/types/scalar/name
  Property: http://www.w3.org/ns/shacl#minLength
  Position: Some(LexicalInformation([(10,17)-(10,20)]))
  Location: file://documentation/validation_tutorial/examples/example6/api.yaml
```


### 3.2 equalsToProperty, disjointWithProperty

`equalsToProperty` and `disjointWithProperty` makes it possible to state that the values in two properties of the same
node must have the same or different values.

The following profile will define two validation rules one stating that `minLength` and `maxLength` for a string as shown
in example 3.1 must be equal or different:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example7/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test7

violation:
  - test-equals
  - test-different

validations:
  test-equals:
    targetClass: raml-shapes.ScalarShape
    message: Min and max length must match in scalar
    propertyConstraints:
      shacl.maxLength:
        equalsToProperty: shacl.minLength

  test-different:
    targetClass: raml-shapes.ScalarShape
    message: Min and max length must not match in scalar
    propertyConstraints:
      shacl.maxLength:
        disjointWithProperty: shacl.minLength
```

If we try to validate the example API spec in section 3.1 with this new profile, the validation about values being the
same will fail:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse -in "OAS 3.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example7/profile.yaml documentation/validation_tutorial/examples/example6/api.yaml
```

```yaml
Model: file://documentation/validation_tutorial/examples/example6/api.yaml
Profile: Test6
Conforms? false
Number of results: 2

Level: Violation

- Source: http://a.ml/vocabularies/data#test-equals
  Message: Min and max length must match in scalar
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example6/api.yaml#/declarations/types/scalar/name
  Property: http://www.w3.org/ns/shacl#maxLength
  Position: Some(LexicalInformation([(11,17)-(11,20)]))
  Location: file://documentation/validation_tutorial/examples/example6/api.yaml
```

If we modify the spec to provide the same value and we re-validate, two new errors will be shown now for the complementary
validation about values being disjoint.

```yaml
openapi: 3.0.0

info:
  title: Example API

components:
  schemas:
    name:
      type: string
      minLength: 100
      maxLength: 100

paths: {}
```

```text
Model: file://documentation/validation_tutorial/examples/example6/api.yaml
Profile: Test7
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#test-different
  Message: Min and max length must not match in scalar
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example6/api.yaml#/declarations/types/scalar/name
  Property: http://www.w3.org/ns/shacl#maxLength
  Position: Some(LexicalInformation([(11,17)-(11,20)]))
  Location: file://documentation/validation_tutorial/examples/example6/api.yaml
```

## 4. Nested node validations and property paths

So far we have discussed examples where constraints were set over properties for a single node.

The custom validation mechanism supports also to define validations over multiple nodes in the same validation rules,
connecting them with nesting constraints:

- *nested*: constrains all nested nodes connected to the target node through some property

As an alternative, the properties for constraints can be defined as a property paths that make it possible to express
nesting traversing the output graph into a simple an efficient way

The following sections review each of these constraints.

### 4.1 nested

`nested` can be used to add additional constraints to nodes nested under the target node and connected through some
specific property.

Consider the following simple RAML API:

File: *RAML_ROOT/documentation/validation_tutorial/examples/example8/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  get:
    queryParameters:
      a:
    body:
      application/json:
        properties:
          b:
```

In this API spec, two scalar RAML types are defined `a` and `b`. `a` is defined as the schema for a `queryParameter` while
`b` is defined as the schema for a property in the request payload.

This spec is parsed as the following JSON-LD graph by AMF:

```bash
java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" documentation/validation_tutorial/examples/example8/api.raml | jq
```
```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Test API"
          }
        ],
        "apiContract:endpoint": [
          {
            "@id": "#/web-api/end-points/%2Fendpoint1",
            "@type": [
              "apiContract:EndPoint",
              "doc:DomainElement"
            ],
            "apiContract:path": [
              {
                "@value": "/endpoint1"
              }
            ],
            "apiContract:supportedOperation": [
              {
                "@id": "#/web-api/end-points/%2Fendpoint1/get",
                "@type": [
                  "apiContract:Operation",
                  "doc:DomainElement"
                ],
                "apiContract:method": [
                  {
                    "@value": "get"
                  }
                ],
                "apiContract:expects": [
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/request",
                    "@type": [
                      "apiContract:Request",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:parameter": [
                      {
                        "@id": "#/web-api/end-points/%2Fendpoint1/get/request/parameter/a",
                        "@type": [
                          "apiContract:Parameter",
                          "doc:DomainElement"
                        ],
                        "core:name": [
                          {
                            "@value": "a"
                          }
                        ],
                        "apiContract:paramName": [
                          {
                            "@value": "a"
                          }
                        ],
                        "apiContract:required": [
                          {
                            "@value": true
                          }
                        ],
                        "apiContract:binding": [
                          {
                            "@value": "query"
                          }
                        ],
                        "raml-shapes:schema": [
                          {
                            "@id": "#/web-api/end-points/%2Fendpoint1/get/request/parameter/a/scalar/schema",
                            "@type": [
                              "raml-shapes:ScalarShape",
                              "raml-shapes:AnyShape",
                              "shacl:Shape",
                              "raml-shapes:Shape",
                              "doc:DomainElement"
                            ],
                            "shacl:datatype": [
                              {
                                "@id": "http://www.w3.org/2001/XMLSchema#string"
                              }
                            ],
                            "shacl:name": [
                              {
                                "@value": "schema"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "apiContract:payload": [
                      {
                        "@id": "#/web-api/end-points/%2Fendpoint1/get/request/application%2Fjson",
                        "@type": [
                          "apiContract:Payload",
                          "doc:DomainElement"
                        ],
                        "core:mediaType": [
                          {
                            "@value": "application/json"
                          }
                        ],
                        "raml-shapes:schema": [
                          {
                            "@id": "#/web-api/end-points/%2Fendpoint1/get/request/application%2Fjson/schema",
                            "@type": [
                              "shacl:NodeShape",
                              "raml-shapes:AnyShape",
                              "shacl:Shape",
                              "raml-shapes:Shape",
                              "doc:DomainElement"
                            ],
                            "shacl:closed": [
                              {
                                "@value": false
                              }
                            ],
                            "shacl:property": [
                              {
                                "@id": "#/web-api/end-points/%2Fendpoint1/get/request/application%2Fjson/schema/property/b",
                                "@type": [
                                  "shacl:PropertyShape",
                                  "shacl:Shape",
                                  "raml-shapes:Shape",
                                  "doc:DomainElement"
                                ],
                                "shacl:path": [
                                  {
                                    "@id": "http://a.ml/vocabularies/data#b"
                                  }
                                ],
                                "raml-shapes:range": [
                                  {
                                    "@id": "#/web-api/end-points/%2Fendpoint1/get/request/application%2Fjson/schema/property/b/scalar/b",
                                    "@type": [
                                      "raml-shapes:ScalarShape",
                                      "raml-shapes:AnyShape",
                                      "shacl:Shape",
                                      "raml-shapes:Shape",
                                      "doc:DomainElement"
                                    ],
                                    "shacl:datatype": [
                                      {
                                        "@id": "http://www.w3.org/2001/XMLSchema#string"
                                      }
                                    ],
                                    "shacl:name": [
                                      {
                                        "@value": "b"
                                      }
                                    ]
                                  }
                                ],
                                "shacl:minCount": [
                                  {
                                    "@value": 1
                                  }
                                ],
                                "shacl:name": [
                                  {
                                    "@value": "b"
                                  }
                                ]
                              }
                            ],
                            "shacl:name": [
                              {
                                "@value": "schema"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example8/api.raml",
      "shacl": "http://www.w3.org/ns/shacl#",
      "raml-shapes": "http://a.ml/vocabularies/shapes#",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
``` 

We could use the `nested` constraint to define a validation only for scalar RAML types defined as schema for parameters. 
In the parsed graph, `apiContract:Parameter` nodes are connected to the `raml-shapes:ScalarShape` used in parameters through
the `raml-shapes:schema` property so that is the property we need to connect the nested validation.

File: *AMF_ROOT/documentation/validation_tutorial/examples/example8/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test8

violation:
  - scalar-parameters

validations:
  scalar-parameters:
    targetClass: apiContract.Parameter
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      raml-shapes.schema:
        minCount: 1
        nested:
          propertyConstraints:
            shacl.minLength:
              minCount: 1
```

With this profile, if we try to validate the API we will obtain one validation violation for the scalar of parameter `a`
while the scalar `b` validates correctly:


```text
Model: file://documentation/validation_tutorial/examples/example8/api.raml
Profile: Test8
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#scalar-parameters
  Message: Scalars in parameters must have minLength defined
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example8/api.raml#/web-api/end-points/%2Fendpoint1/get/request/parameter/a
  Property: http://a.ml/vocabularies/shapes#schema
  Position: Some(LexicalInformation([(8,6)-(9,0)]))
  Location: file://documentation/validation_tutorial/examples/example8/api.raml
```

Nested can be applied multiple times in a validation rule definition. For example the previous rule could be rewritten
targeting the `apiContract:Request` node that is the parent of the `apiContract:Parameter` node:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example8/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test8

violation:
  - scalar-parameters

validations:
  scalar-parameters:
    targetClass: apiContract.Request
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.parameter:
        minCount: 1
        nested:
          propertyConstraints:
            raml-shapes.schema:
              minCount: 1
              nested:
                propertyConstraints:
                  shacl.minLength:
                    minCount: 1
```

### 4.2 Property paths

At the end of section 4.1 we have seen how multiple nested clasuses can be used to describe a path of validations through
the parsed output graph.

This can be useful if defining additional constraints at the different nodes being traversed is required, however, as a
mechanism to reach a target nested node can be too verbose and error prone.

Property paths are a simple way of expressing traversals through the graph being validated to reach the target node.

Property paths are built using a simple subset of SPARQL property path syntax:

- *Predicates*: Any property identifier, like `core.name` or `apiContract.expects` are valid property paths
- *Sequence paths*: Sequences in the form `a / b / c / ...` where `a`, `a` and `c` are valid property paths
- *Alternate paths*: Alternative paths in the form `a | b | c | ...` where `a`, `a` and `c` are valid property paths
- *Inverse paths*: Expressed as `a^` where `a` is a valid predicates like `core.name` or `apiContract.expects`
- *ZeroOrMore paths* Expresed as `a*` where `a` is a valid predicates like `core.name` or `apiContract.expects`

All these types of paths can be combined in complex expressions reaching any part of the output graph from a target node.
Notice that `sequence paths` have a greater priority than `alternate paths` in path expressions. Parenthesis can be used
to change the associativity in a path expression.

Let's review each of these types of path expressions. 

#### 4.2.1 Sequence paths

Sequence paths are just concatenation of properties from one node to a set of target nodes.

The last example of section 4.1 could be rewritten to simply use a path `apiContract.parameter / raml-shapes.schema` 
instead of two nested clauses.

File: *AMF_ROOT/documentation/validation_tutorial/examples/example9/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test9

violation:
  - scalar-parameters

validations:

  scalar-parameters:
    targetClass: apiContract.Request
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.parameter / raml-shapes.schema:
        nested:
          shacl.minLength:
            minCount: 1
```

#### 4.2.2 Alternate paths

Alternate paths makes it possible to reach target nodes in different parts of the output graph that must be validated in
the same way.

For example, in the API spec used as example in section 4.1 scalar RAML types could appear in parameters but also as
properties in the payload. If we wanted to constrain both types of scalar types, and only the ones at those positions, 
with the same constraint for `minLength`, we could use an `alterante path` to apply it in both cases:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example9/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test9b

violation:
  - scalar-parameters

validations:

  scalar-parameters:
    targetClass: apiContract.Operation
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.expects / (apiContract.parameter / raml-shapes.schema | apiContract.payload / raml-shapes.schema / shacl.property / raml-shapes.range) :
        nested:
          propertyConstraints:
            shacl.minLength:
              minCount: 1
```

In this profile we first select scalar type nodes in the parameters and request body using the path 
expression `apiContract.expects / (apiContract.parameter / raml-shapes.schema | apiContract.payload / raml-shapes.schema / shacl.property / raml-shapes.range)`.

Once the target nodes have been selected we validate the `shacl.minLength` property in the node through the `nested` constraint.

If we try to parse the example in section 4.1 with this profile we will obtain two validation errors, one for the parameter, 
another one for the body:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example9/profile2.yaml documentation/validation_tutorial/examples/example8/api.raml
```

```text
Model: file://documentation/validation_tutorial/examples/example8/api.raml
Profile: Test9b
Conforms? false
Number of results: 2

Level: Violation

- Source: http://a.ml/vocabularies/data#scalar-parameters
  Message: Scalars in parameters must have minLength defined
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example8/api.raml#/web-api/end-points/%2Fendpoint1/get
  Property: 
  Position: Some(LexicalInformation([(6,2)-(13,0)]))
  Location: file://documentation/validation_tutorial/examples/example8/api.raml

- Source: http://a.ml/vocabularies/data#scalar-parameters
  Message: Scalars in parameters must have minLength defined
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example8/api.raml#/web-api/end-points/%2Fendpoint1/get
  Property: 
  Position: Some(LexicalInformation([(6,2)-(13,0)]))
  Location: file://documentation/validation_tutorial/examples/example8/api.raml
```

#### 4.2.3 Inverse paths

Inverse paths traverse the graph in the opposite direction from target node to parent node, instead of from target node
to nested node.

#### 4.2.4 ZeroOrMore paths

ZeroOrMore paths traverse a relationship in a transitive way and are specially useful to express constraints over recursive
data structures in the output parsed JSON-LD graph, for example to constrain RAML data types or JSON schema shapes.

## 5. Qualified constraints

Qualified constraints makes it possible to express validation rules that match only a minimum or maximum number of the target
nodes selected by a particular constraint.

These are the qualified constraints supported:

- *atLeast*: Makes it possible to check that a particular validation rule matches a minimum number of the target nodes
- *atMost*: Makes it possible to check that a particular validation rule matches a maximum number of the target nodes

The following API describes a RAML API with different endpoints supporting each a different set of HTTP operations:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example10/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  get:

/endpoint2:
  get:
  post:
```

This API generates the following JSON-LD graph when parsed by AMF:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example9/profile2.yaml documentation/validation_tutorial/examples/example10/api.raml | jq .
```

```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Test API"
          }
        ],
        "apiContract:endpoint": [
          {
            "@id": "#/web-api/end-points/%2Fendpoint1",
            "@type": [
              "apiContract:EndPoint",
              "doc:DomainElement"
            ],
            "apiContract:path": [
              {
                "@value": "/endpoint1"
              }
            ],
            "apiContract:supportedOperation": [
              {
                "@id": "#/web-api/end-points/%2Fendpoint1/get",
                "@type": [
                  "apiContract:Operation",
                  "doc:DomainElement"
                ],
                "apiContract:method": [
                  {
                    "@value": "get"
                  }
                ]
              }
            ]
          },
          {
            "@id": "#/web-api/end-points/%2Fendpoint2",
            "@type": [
              "apiContract:EndPoint",
              "doc:DomainElement"
            ],
            "apiContract:path": [
              {
                "@value": "/endpoint2"
              }
            ],
            "apiContract:supportedOperation": [
              {
                "@id": "#/web-api/end-points/%2Fendpoint2/get",
                "@type": [
                  "apiContract:Operation",
                  "doc:DomainElement"
                ],
                "apiContract:method": [
                  {
                    "@value": "get"
                  }
                ]
              },
              {
                "@id": "#/web-api/end-points/%2Fendpoint2/post",
                "@type": [
                  "apiContract:Operation",
                  "doc:DomainElement"
                ],
                "apiContract:method": [
                  {
                    "@value": "post"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example10/api.raml",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
```

Notice how each parsed `apiContract:EndPoint` has an associated `apiContrat.Operation` each with a number of defined 
`apiContract:method` (`get` or `post`).

We could define a profile to check that each endpoint hast *at least* one POST operation:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example10/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test10

violation:
  - at-least-one-post

validations:

  at-least-one-post:
    message: Endpoints must have a POST method
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation:
        atLeast:
          count: 1
          validation:
            propertyConstraints:
              apiContract.method:
                in: [ post ]
```

If we try to validate the API against this profile we will get one error about the endpoints without the post operation:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example10/profile.yaml documentation/validation_tutorial/examples/example10/api.raml
``` 

```yaml
Model: file://documentation/validation_tutorial/examples/example10/api.raml
Profile: Test10
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#at-least-one-post
  Message: Endpoints must have a POST method
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example10/api.raml#/web-api/end-points/%2Fendpoint1
  Property: http://a.ml/vocabularies/apiContract#supportedOperation
  Position: Some(LexicalInformation([(6,2)-(8,0)]))
  Location: file://documentation/validation_tutorial/examples/example10/api.raml
```

In the same way we could generate a profile validating that an API is read-only by validating that no endpoint has a 
put, patch, post or delete methods using a `atMost` qualified constraint with value `0`:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example10/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test10b

violation:
  - read-only-endpoints

validations:

  read-only-endpoints:
    message: Endpoints must be read-only
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation:
        atMost:
          count: 0
          validation:
            propertyConstraints:
              apiContract.method:
                in: [ post, put, patch, delete ]
```

Trying to parse with this new profile will raise a validation error for the endpoint with a `post` method:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example10/profile2.yaml documentation/validation_tutorial/examples/example10/api.raml
```

```text
Model: file://documentation/validation_tutorial/examples/example10/api.raml
Profile: Test10b
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#read-only-endpoints
  Message: Endpoints must be read-only
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example10/api.raml#/web-api/end-points/%2Fendpoint2
  Property: http://a.ml/vocabularies/apiContract#supportedOperation
  Position: Some(LexicalInformation([(9,2)-(10,0)]))
  Location: file://documentation/validation_tutorial/examples/example10/api.raml
```

## 6. Logical constraints

Logical constraints makes it possible to combine set of constraints using basic boolean logic operators like: `and`, `or`,
`not` and `xone` (exclusive or).

- *and*: Combines a set of validation rules using a logical and
- *or*: Combines a set of validation rules using a logical or
- *not*: Negates a validation rule
- *xone*: Combines a set of validation rules using a logical exclusive or

Logical constraints are introduced at the top level definition of a validation rule and can be combined and nested to achieve
complex validation logic.

In the following sections we will review each of this constraints with some examples.

### 6.1 and

`And` combines multiple rules using a logical and to compute the final validation result.

The following RAML API shows a simple RAML API where a GET operation defines multiple status codes for the operation
responses: 

File: *AMF_ROOT/documentation/validation_tutorial/examples/example11/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint:
  get:
    responses:
      200:
      201:
      300:
      400:
      401:
```

The following JSON-LD graph is generated when the spec is parsed by AMF:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example10/profile2.yaml documentation/validation_tutorial/examples/example11/api.raml | jq .
```

```json
[
  {
    "@id": "",
    "@type": [
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "#/web-api",
        "@type": [
          "apiContract:WebAPI",
          "doc:RootDomainElement",
          "doc:DomainElement"
        ],
        "core:name": [
          {
            "@value": "Test API"
          }
        ],
        "apiContract:endpoint": [
          {
            "@id": "#/web-api/end-points/%2Fendpoint1",
            "@type": [
              "apiContract:EndPoint",
              "doc:DomainElement"
            ],
            "apiContract:path": [
              {
                "@value": "/endpoint1"
              }
            ],
            "apiContract:supportedOperation": [
              {
                "@id": "#/web-api/end-points/%2Fendpoint1/get",
                "@type": [
                  "apiContract:Operation",
                  "doc:DomainElement"
                ],
                "apiContract:method": [
                  {
                    "@value": "get"
                  }
                ],
                "apiContract:returns": [
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/200",
                    "@type": [
                      "apiContract:Response",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:statusCode": [
                      {
                        "@value": "200"
                      }
                    ],
                    "core:name": [
                      {
                        "@value": "200"
                      }
                    ]
                  },
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/201",
                    "@type": [
                      "apiContract:Response",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:statusCode": [
                      {
                        "@value": "201"
                      }
                    ],
                    "core:name": [
                      {
                        "@value": "201"
                      }
                    ]
                  },
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/300",
                    "@type": [
                      "apiContract:Response",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:statusCode": [
                      {
                        "@value": "300"
                      }
                    ],
                    "core:name": [
                      {
                        "@value": "300"
                      }
                    ]
                  },
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/400",
                    "@type": [
                      "apiContract:Response",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:statusCode": [
                      {
                        "@value": "400"
                      }
                    ],
                    "core:name": [
                      {
                        "@value": "400"
                      }
                    ]
                  },
                  {
                    "@id": "#/web-api/end-points/%2Fendpoint1/get/401",
                    "@type": [
                      "apiContract:Response",
                      "apiContract:Message",
                      "doc:DomainElement"
                    ],
                    "apiContract:statusCode": [
                      {
                        "@value": "401"
                      }
                    ],
                    "core:name": [
                      {
                        "@value": "401"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "doc:version": [
      {
        "@value": "2.1.0"
      }
    ],
    "doc:root": [
      {
        "@value": true
      }
    ],
    "@context": {
      "@base": "file://documentation/validation_tutorial/examples/example11/api.raml",
      "doc": "http://a.ml/vocabularies/document#",
      "apiContract": "http://a.ml/vocabularies/apiContract#",
      "core": "http://a.ml/vocabularies/core#"
    }
  }
]
```

We could write a simple validation profile to check that every get operation has defined documentation for status codes 
 in the ranges 2XX, 4XX and 5XX.
 
 File: *$AMF_ROOT/documentation/validation_tutorial/examples/example11/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test11

violation:
  - and-rule

validations:

  and-rule:
    message: Operations must have 2xx, 4xx and 5xx status codes
    targetClass: apiContract.Operation
    and:
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
               propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^2[0-9]{2}$
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
                propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^4[0-9]{2}$
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
                propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^5[0-9]{2}$
```

If we validate the API spec with this profile an error will be reported for the missing error in the 5XX range:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example11/profile.yaml documentation/validation_tutorial/examples/example11/api.raml | jq .
```

```yaml
Model: file://documentation/validation_tutorial/examples/example11/api.raml
Profile: Test11
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#and-rule
  Message: GET operations must have 2xx, 4xx and 5xx status codes
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example11/api.raml#/web-api/end-points/%2Fendpoint1/get
  Property: 
  Position: Some(LexicalInformation([(6,2)-(12,10)]))
  Location: file://documentation/validation_tutorial/examples/example11/api.raml
```

### 6.2 or

In section 6.1 we have defined a validation profile with a rule to validate that all operation has status codes defined
in the ranges 2XX, 3XX and 5XX.

However sometimes we would like to express conditions for certain target nodes to validate. `or` logical constraints can
be used to achieve this behaviour. For example, let's refine our rule to validate status codes in the ranges 2XX, 3XX
and 5XX only for GET operations.

We can achieve this expressing in the validation rule that the operation must validate the status code condition or be
a PUT, POST, DELETE or PATCH operation:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example12/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test12

violation:
  - and-or-rule

validations:

  and-or-rule:
    message: GET operations must have 2xx, 4xx and 5xx status codes
    targetClass: apiContract.Operation
    or:
      - propertyConstraints:
          apiContract.method:
            in: [ post, put, patch, delete ]
      - and:
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^2[0-9]{2}$
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^4[0-9]{2}$
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^5[0-9]{2}$
```

If we use this profile the API discussed in section 6.1 will still fail:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example12/profile.yaml documentation/validation_tutorial/examples/example11/api.raml | jq .
```

```text
Model: file://documentation/validation_tutorial/examples/example11/api.raml
Profile: Test12
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/data#and-or-rule
  Message: GET operations must have 2xx, 4xx and 5xx status codes
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example11/api.raml#/web-api/end-points/%2Fendpoint1/get
  Property: 
  Position: Some(LexicalInformation([(6,2)-(12,10)]))
  Location: file://documentation/validation_tutorial/examples/example11/api.raml
```

However, if we define a new API spec with the same operation and list of status codes but for a `post` method, it will validate correctly:

File: *$AMF_ROOT/documentation/validation_tutorial/examples/example12/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  post:
    responses:
      200:
      201:
      300:
      400:
      401:
```

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar validate --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example12/profile.yaml documentation/validation_tutorial/examples/example12/api.raml | jq .
```
```json
{
  "@type": "http://www.w3.org/ns/shacl#ValidationReport",
  "http://www.w3.org/ns/shacl#conforms": true
}
```

### 6.3 not

`not`makes it possible to negate a validation rule and combine it logically with other rules.

For example, let's continue refining the example discussed in section 6.2. We can use `not` to simplify the constraint
about the method being either `put`, `post`, `delete` or `patch` by simply asserting that the method must not be `get`.

Additionally we can add another rule to the top-level conjunction to avoid `get` operations returning `201` (created) status
codes:

File: *documentation/validation_tutorial/examples/example13/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test13

violation:
  - and-or-not-rule

validations:

  and-or-not-rule:
    message: GET operations must have 2xx, 4xx and 5xx status codes but no 201
    targetClass: apiContract.Operation
    or:
      - not:
          propertyConstraints:
            apiContract.method:
              in: [ get ]
      - and:
          - not:
              propertyConstraints:
                apiContract.returns:
                  atLeast:
                    count: 1
                    validation:
                      propertyConstraints:
                        apiContract.statusCode:
                          pattern: "^201$"
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^2[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^4[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^5[0-9]{2}$
```

### 6.4 xone

The final logical constraint is `xone` that expresses and exclusive or logical constraint between a set of validation rules.

To show an example of `xone` usage let's iterate once more over the status codes validation example, and let's add a 
validation rule to the top level conjunction checking that any operations in endpoints must either support `put` or `patch` but not both of them:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example14/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test14

violation:
  - patch-xor-put
  - and-or-not-rule

validations:

  patch-xor-put:
    message: Any operation must optionally support either support put or post
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation:
        atMost:
          count: 1
          validation:
            xone:
              - propertyConstraints:
                  apiContract.method:
                    in: [ put ]
              - propertyConstraints:
                  apiContract.method:
                    in: [ patch ]

  and-or-not-rule:
    message: GET operations must have 2xx, 4xx and 5xx status codes but no 201
    targetClass: apiContract.Operation
    or:
      - not:
          propertyConstraints:
            apiContract.method:
              in: [ get ]
      - and:
          - not:
              propertyConstraints:
                apiContract.returns:
                  atLeast:
                    count: 1
                    validation:
                      propertyConstraints:
                        apiContract.statusCode:
                          pattern: "^201$"
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^2[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^4[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^5[0-9]{2}$
```

## 7. Severity levels and modularity

Let's look at a simple RAML spec:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example15/api.raml*
```yaml
#%RAML 1.0


/endpoint1:
  get:
    responses:
      200:
```

This spec is invalid according to standard RAML validation rules since it is missing the mandatory title.

If we try to validate with AMF a validation error will be returned:

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" documentation/validation_tutorial/examples/example15/api.raml | jq .
```

```text
Model: file://documentation/validation_tutorial/examples/example15/api.raml
Profile: AMF Graph
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/amf/parser#WebAPI-name-minCount
  Message: API title is mandatory
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example15/api.raml#/web-api
  Property: http://a.ml/vocabularies/core#name
  Position: Some(LexicalInformation([(3,0)-(6,10)]))
  Location: file://documentation/validation_tutorial/examples/example15/api.raml

```

This validation is a default validation, defined in the default AMF validation profile (see the `AMF Graph` as the name of the profile in the report).

Now, if we try to validate the same API with a custom validation profile, in this case an empty one,
the standard RAML validation will not be checked:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example15/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test15
```

```bash
java -jar amf-4.1.0-SNAPSHOT.jar validate --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example15/profile.yaml documentation/validation_tutorial/examples/example15/api.raml | jq .
```

```json
{
  "@type": "http://www.w3.org/ns/shacl#ValidationReport",
  "http://www.w3.org/ns/shacl#conforms": true
}
```

We can load all the default RAML, OAS or Async API validations extending these default profiles in our profile definition:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example15/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test15b

extends: RAML
```

```bash
$ java -jar amf-4.1.0-SNAPSHOT.jar parse --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example15/profile2.yaml documentation/validation_tutorial/examples/example15/api.raml | jq .
```

```text
Model: file://documentation/validation_tutorial/examples/example15/api.raml
Profile: Test15b
Conforms? false
Number of results: 1

Level: Violation

- Source: http://a.ml/vocabularies/amf/parser#WebAPI-name-minCount
  Message: API title is mandatory
  Level: Violation
  Target: file://documentation/validation_tutorial/examples/example15/api.raml#/web-api
  Property: http://a.ml/vocabularies/core#name
  Position: Some(LexicalInformation([(3,0)-(6,10)]))
  Location: file://documentation/validation_tutorial/examples/example15/api.raml
```

Any loaded profile can be extended by other profile, not only the default ones, as long as they are loaded in memory by the parser.
From the command line this can be achieved passing more profile document URLs to the `-cp` command line flag.

When we extend a profile, all the validation rules defined in the profile are loaded. In some situations we might want to
disable or change the severity of the existing validations.

In this case, we would like to transform the default validation about the missing title in just a warning.

The top level properties `info`, `warning`, `violation` can be used to change the severity of all the loaded validations.
This is also true for the violations defined in the profile document. In the previous examples, we have assigned all the 
validation rules to the `violation` level automatically.   

Validations can also be disabled assigning them to the `disabled` property:

File: *AMF_ROOT/documentation/validation_tutorial/examples/example15/profile3.yaml*
```yaml
#%Validation Profile 1.0

profile: Test15b

extends: RAML

info:
  - amf-parser.WebAPI-name-minCount
```

If we generate the SHACL validation report, we will see how the validation has now been reported as a simple info notification:

```bash
 $ java -jar amf-4.1.0-SNAPSHOT.jar validate --compacted true -in "RAML 1.0" -mime-in "application/yaml" -cp file://documentation/validation_tutorial/examples/example15/profile3.yaml documentation/validation_tutorial/examples/example15/api.raml | jq .
```

```json
{
  "@type": "http://www.w3.org/ns/shacl#ValidationReport",
  "http://www.w3.org/ns/shacl#conforms": true,
  "http://www.w3.org/ns/shacl#result": [
    {
      "@type": "http://www.w3.org/ns/shacl#ValidationResult",
      "http://www.w3.org/ns/shacl#resultSeverity": {
        "@id": "http://www.w3.org/ns/shacl#Info"
      },
      "http://www.w3.org/ns/shacl#focusNode": {
        "@id": "file://documentation/validation_tutorial/examples/example15/api.raml#/web-api"
      },
      "http://www.w3.org/ns/shacl#resultPath": {
        "@id": "http://a.ml/vocabularies/core#name"
      },
      "http://www.w3.org/ns/shacl#resultMessage": "API title is mandatory",
      "http://www.w3.org/ns/shacl#sourceShape": {
        "@id": "http://a.ml/vocabularies/amf/parser#WebAPI-name-minCount"
      },
      "http://a.ml/vocabularies/amf/parser#lexicalPosition": {
        "@type": "http://a.ml/vocabularies/amf/parser#Position",
        "http://a.ml/vocabularies/amf/parser#start": {
          "@type": "http://a.ml/vocabularies/amf/parser#Location",
          "http://a.ml/vocabularies/amf/parser#line": 3,
          "http://a.ml/vocabularies/amf/parser#column": 0
        },
        "http://a.ml/vocabularies/amf/parser#end": {
          "@type": "http://a.ml/vocabularies/amf/parser#Location",
          "http://a.ml/vocabularies/amf/parser#line": 6,
          "http://a.ml/vocabularies/amf/parser#column": 10
        }
      }
    }
  ]
}
```

## 8. SPARQL rules

SPARQL a W3C standard graph query language can be used to define additional validation rules.

The following profile writes a simple rule to check if the version of the apiContract.WebAPI spec is defined:

```yaml
#%Validation Profile 1.0

profile: Test16

violation:
  - simple-query

validations:

  simple-query:
    message: GET operations must have 2xx, 4xx and 5xx status codes but no 201
    targetClass: apiContract.WebAPI
    query: |
      SELECT $this (!BOUND(?version) as ?value)
      WHERE {
          $this a apiContract:WebAPI .
          OPTIONAL {
            $this apiContract:version ?version
          }
      }
```